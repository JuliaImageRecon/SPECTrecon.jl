var documenterSearchIndex = {"docs":
[{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"EditURL = \"https://github.com/JeffFessler/SPECTrecon.jl/blob/master/docs/lit/examples/2-rotate.jl\"","category":"page"},{"location":"examples/2-rotate/#rotate","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"","category":"section"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"This page explains the image rotation portion of the Julia package SPECTrecon.jl.","category":"page"},{"location":"examples/2-rotate/#Setup","page":"SPECTrecon rotation","title":"Setup","text":"","category":"section"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Packages needed here.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"using SPECTrecon\nusing MIRTjim: jim, prompt\nusing Plots: scatter, scatter!, plot!, default\ndefault(markerstrokecolor=:auto, markersize=3)","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"examples/2-rotate/#Overview","page":"SPECTrecon rotation","title":"Overview","text":"","category":"section"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The first step in SPECT image forward projection is to rotate each slice of a 3D image volume to the appropriate view angle. In principle one could use any of numerous candidate interpolation methods for this task. However, because emission images are nonnegative and maximum likelihood methods for SPECT image reconstruction exploit that nonnegativity, it is desirable to use interpolators that preserve nonnegativity. This constraint rules out quadratic and higher B-splines, including the otherwise attractive cubic B-spline methods. On the other hand, nearest-neighbor interpolation (equivalent to 0th-order B-splines) does not provide adequate image quality. This leaves 1st-order interpolation methods as the most viable options.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"This package supports two 1st-order linear interpolators:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"2D bilinear interpolation,\na 3-pass rotation method based on 1D linear interpolation.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Because image rotation is done repeatedly (for every slice of both the emission image and the attenuation map, for both projection and back-projection, and for multiple iterations), it is important for efficiency to use mutating methods rather than to repeatedly make heap allocations.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Following other libraries like FFTW.jl, the rotation operations herein start with a plan where work arrays are preallocated for subsequent use. The plan is a Vector of PlanRotate objects: one for each thread. (Parallelism is across slices for a 3D image volume.) The number of threads defaults to Threads.nthreads(), but one can select any number and selecting more threads than number of cores empirically can reduce computation time.","category":"page"},{"location":"examples/2-rotate/#Example","page":"SPECTrecon rotation","title":"Example","text":"","category":"section"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Start with a 3D image volume (just 2 slices here for simplicity).","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"T = Float32 # work with single precision to save memory\nimage = zeros(T, 64, 64, 2)\nimage[30:50,20:30,1] .= 1\nimage[25:28,20:40,2] .= 1\njim(image, \"Original image\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Now plan the rotation by specifying","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"the image size (must be square)\nthe DataType used for the work arrays\nthe (maximum) number of threads.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"plan2 = plan_rotate(size(image, 1); T, nthread = Threads.nthreads())","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here are the internals for the plan for the first thread:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"plan2[1]","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"With this plan preallocated, now we can rotate the image volume, specifying the rotation angle in radians:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"result2 = similar(image) # allocate memory for the result\nimrotate!(result2, image, π/6, plan2) # mutates the first argument\njim(result2, \"Rotated image by π/6 (2D bilinear)\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The default, shown above, uses 2D bilinear interpolation for rotation. That default is the recommended approach because it is faster.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here is the 3-pass 1D interpolation approach, included mainly for checking consistency with the historical ASPIRE approach used in Matlab version of MIRT.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"plan1 = plan_rotate(size(image, 1); T, nthread = Threads.nthreads(), method=:one)","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here are the plan internals for the first thread:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"plan1[1]","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The results of rotation using 3-pass 1D interpolation look quite similar:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"result1 = similar(image)\nimrotate!(result1, image, π/6, plan1)\njim(result1, \"Rotated image by π/6 (3-pass 1D)\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here are the difference images for comparison.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"jim(result1 - result2, \"Difference images\")\n\n\n### Adjoint","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"To ensure adjoint consistency between SPECT forward- and back-projection, there is also an adjoint routine:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"adj2 = similar(result2)\nimrotate_adj!(adj2, result2, π/6, plan2)\njim(adj2, \"Adjoint image rotation (2D)\")\n\nadj1 = similar(result1)\nimrotate_adj!(adj1, result1, π/6, plan1)\njim(adj1, \"Adjoint image rotation (3-pass 1D)\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The adjoint is not the same as the inverse so one does not expect the output here to match the original image!","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"### LinearMap","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"One can form a linear map corresponding to image rotation using LinearMapAA. An operator like this may be useful as part of a motion-compensated image reconstruction method.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"using LinearMapsAA: LinearMapAA\n\nnx = 20 # small size for illustration\nr1 = plan_rotate(nx; T, nthread = 1, method=:two)[1]\nr2 = plan_rotate(nx; T, nthread = 1, method=:one)[1]\nidim = (nx,nx)\nodim = (nx,nx)\nforw! = (y,x) -> imrotate!(y, x, π/6, r1)\nback! = (x,y) -> imrotate_adj!(x, y, π/6, r1)\nA1 = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\nforw! = (y,x) -> imrotate!(y, x, π/6, r2)\nback! = (x,y) -> imrotate_adj!(x, y, π/6, r2)\nA2 = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\n\nAfull1 = Matrix(A1)\nAadj1 = Matrix(A1')\nAfull2 = Matrix(A2)\nAadj2 = Matrix(A2')\njim(cat(dims=3, Afull1', Aadj1', Afull2', Aadj2'), \"Linear map for 2D rotation and its adjoint\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The following verify adjoint consistency:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"@assert Afull1' ≈ Aadj1\n@assert Afull2' ≈ Aadj2","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Applying this linear map to a 2D or 3D image performs rotation:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"image2 = zeros(nx,nx); image2[4:6, 5:13] .= 1\njim(cat(dims=3, image2, A2 * image2), \"Rotation via linear map: 2D\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here is 3D too. The A2 * image3 here uses the advanced \"operator\" feature of LinearMapsAA.jl.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"image3 = cat(dims=3, image2, image2')\njim(cat(dims=4, image3, A2 * image3), \"Rotation via linear map: 3D\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Examine row and column sums of linear map","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"scatter(xlabel=\"pixel index\", ylabel=\"row or col sum\")\nscatter!(vec(sum(Afull1, dims=1)), label=\"dim1 sum1\", marker=:x)\nscatter!(vec(sum(Afull1, dims=2)), label=\"dim2 sum1\", marker=:square)\nscatter!(vec(sum(Afull2, dims=1)), label=\"dim1 sum2\")\nscatter!(vec(sum(Afull2, dims=2)), label=\"dim2 sum2\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"history/#History","page":"History","title":"History","text":"","category":"section"},{"location":"history/","page":"History","title":"History","text":"The SPECT forward and back-projection method implemented here is based on the 1992 paper by GL Zeng & GT Gullberg \"Frequency domain implementation of the three-dimensional geometric point response correction in SPECT imaging\" (DOI).","category":"page"},{"location":"history/","page":"History","title":"History","text":"Historically there have been relatively few open-source libraries for SPECT image reconstruction, and to the best of our knowledge source code for the Zeng & Gullberg approach has not been available prior to this package.","category":"page"},{"location":"history/","page":"History","title":"History","text":"Starting in about 1995, the ASPIRE library, developed in the early 1990s at the University of Michigan, began providing precompiled binaries (from C99 source code) for 2D SPECT image reconstruction with documentation.","category":"page"},{"location":"history/","page":"History","title":"History","text":"In about 1997, a 3D version of ASPIRE for SPECT reconstruction became available, again as precompiled binaries with documentation. Anastasia Yendiki was a key contributor to the SPECT code. As noted in a 2001 technical report we took pains to ensure that the forward and back-projector were (adjoint) consistent pairs. Around 2001 the work was extended to consider blob basis functions, leading to a 2004 comparison paper.","category":"page"},{"location":"history/","page":"History","title":"History","text":"Somewhere during that period the 3D SPECT projector / backprojector became available as precompiled MEX files for use with the Matlab version of the Michigan Image Reconstruction Toolbox.","category":"page"},{"location":"history/","page":"History","title":"History","text":"The 3D version in ASPIRE precomputes rotated versions of the attenuation map, to save computation at the price of substantially more memory. That trade-off was reasonable in the era before machine learning. Today, with a focus on end-to-end training of image reconstruction methods in all modalities, including SPECT, it is desirable to have methods that use less memory to facilitate GPU implementations. This open-source Julia package is designed for the machine learning era. ","category":"page"},{"location":"history/","page":"History","title":"History","text":"Development work on this package is supported in part by the following projects led by Dr. Yuni Dewaraja:","category":"page"},{"location":"history/","page":"History","title":"History","text":"NIH Grant R01 EB022075\nNIH Grant R01 CA240706","category":"page"},{"location":"methods/#Methods-list","page":"Methods","title":"Methods list","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"","category":"page"},{"location":"methods/#Methods-usage","page":"Methods","title":"Methods usage","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Modules = [SPECTrecon]","category":"page"},{"location":"methods/#SPECTrecon.SPECTrecon","page":"Methods","title":"SPECTrecon.SPECTrecon","text":"SPECTrecon\n\nSystem matrix (forward and back-projector) for SPECT image reconstruction.\n\n\n\n\n\n","category":"module"},{"location":"methods/#SPECTrecon.Rotate1D","page":"Methods","title":"SPECTrecon.Rotate1D","text":"Rotate1D = RotateMode{:one}()\n\nRotate using 3-pass 1D interpolation\n\n\n\n\n\n","category":"constant"},{"location":"methods/#SPECTrecon.Rotate2D","page":"Methods","title":"SPECTrecon.Rotate2D","text":"Rotate2D = RotateMode{:two}()\n\nRotate using 1-pass 2D bilinear interpolation\n\n\n\n\n\n","category":"constant"},{"location":"methods/#SPECTrecon.PlanPSF","page":"Methods","title":"SPECTrecon.PlanPSF","text":"PlanPSF(nx::Int, nz::Int, nx_psf::Int; T::DataType)\n\nMake struct for storing work arrays and factors for 2D convolution for one thread Currently PSF must be square, i.e., nx_psf = nz_psf\n\nT datatype of work arrays\nnx must be Int\nnz must be Int\nnx_psf must be Int\npadsize{padup, paddown, padleft, padright} Tuple of padsize\nworkmat [nx+padup+paddown, nz+padleft+padright] 2D padded image for FFT convolution\nworkvecx [nx+padup+paddown,]: 1D work vector\nworkvecz [nz+padleft+padright,]: 1D work vector\nimg_compl [nx+padup+paddown, nz+padleft+padright]: 2D [complex] padded image for fft\nker_compl [nx+padup+paddown, nz+padleft+padright]: 2D [complex] padded image for fft\nfft_plan plan for doing fft, see plan_fft!\nifft_plan plan for doing ifft, see plan_ifft!\n\n\n\n\n\n","category":"type"},{"location":"methods/#SPECTrecon.PlanRotate","page":"Methods","title":"SPECTrecon.PlanRotate","text":"PlanRotate{T, R}\n\nStruct for storing work arrays and factors for 2D square image rotation for one thread\n\nT datatype of work arrays (default Float32)\nR::RotateMode\nnx::Int image size\npadsize::Int : pad each side of image by this much\nworkmat1 [nx + 2 * padsize, nx + 2 * padsize] padded work matrix\nworkmat2 [nx + 2 * padsize, nx + 2 * padsize] padded work matrix\nworkvec [nx + 2 * padsize, ] padded work vector\ninterp::SparseInterpolator{T, 2, 1}\n\n\n\n\n\n","category":"type"},{"location":"methods/#SPECTrecon.RotateMode","page":"Methods","title":"SPECTrecon.RotateMode","text":"RotateMode\n\nType to control image rotation method.\n\nRotate1D : 3-pass 1D interpolation\nRotate2D : 1-pass 2D bilinear interpolation\n\n\n\n\n\n","category":"type"},{"location":"methods/#Base.show-Union{Tuple{R}, Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, Array{PlanRotate{T, R}, 1}}} where {T, R}","page":"Methods","title":"Base.show","text":"show(io::IO, mime::MIME\"text/plain\", vp::Vector{<:PlanRotate})\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Union{Tuple{R}, Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, PlanRotate{T, R}}} where {T, R}","page":"Methods","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", plan::PlanRotate)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.sizeof-Tuple{T} where T<:Union{PlanRotate, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"Base.sizeof","text":"sizeof(::PlanRotate)\n\nShow size in bytes of PlanRotate object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject!-Tuple{AbstractArray{var\"#s30\", 3} where var\"#s30\"<:Number, AbstractMatrix{var\"#s19\"} where var\"#s19\"<:Number, SPECTplan, Int64}","page":"Methods","title":"SPECTrecon.backproject!","text":"backproject!(image, view, plan, viewidx)\n\nBackproject a single view.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject!-Tuple{AbstractArray{var\"#s6\", 3} where var\"#s6\"<:Number, AbstractArray{var\"#s5\", 3} where var\"#s5\"<:Number, SPECTplan}","page":"Methods","title":"SPECTrecon.backproject!","text":"backproject!(image, views, plan ; index)\n\nBackproject multiple views into image. Array image is not initialized to zero; caller must do that.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject!-Tuple{AbstractArray{var\"#s85\", 3} where var\"#s85\"<:Number, AbstractMatrix{var\"#s83\"} where var\"#s83\"<:Number, SPECTplan, Int64, Int64}","page":"Methods","title":"SPECTrecon.backproject!","text":"backproject!(image, view, plan, thid, viewidx)\n\nBackproject a single view.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject-Tuple{AbstractArray{var\"#s19\", 3} where var\"#s19\"<:Number, AbstractArray{var\"#s18\", 3} where var\"#s18\"<:Number, AbstractArray{var\"#s17\", 4} where var\"#s17\"<:Number, Number}","page":"Methods","title":"SPECTrecon.backproject","text":"image = backproject(views, mumap, psfs, dy; interpmeth, kwargs...)\n\nSPECT backproject views using attenuation map mumap and PSF array psfs for pixel size dy. This method initializes the plan as a convenience. Most users should use backproject! instead after initializing those, for better efficiency.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject-Tuple{AbstractArray{var\"#s87\", 3} where var\"#s87\"<:Number, SPECTplan}","page":"Methods","title":"SPECTrecon.backproject","text":"image = backproject(views, plan ; kwargs...)\n\nSPECT backproject views; this allocates the returned 3D array.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.copy3dj!-Tuple{AbstractMatrix{T} where T, AbstractArray{var\"#s17\", 3} where var\"#s17\", Int64}","page":"Methods","title":"SPECTrecon.copy3dj!","text":"copy3dj!(mat2d, mat3d, j)\n\nNon-allocating mat2d .= mat3d[:,j,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv!-Tuple{AbstractMatrix{var\"#s11\"} where var\"#s11\"<:Number, AbstractMatrix{var\"#s6\"} where var\"#s6\"<:Number, AbstractMatrix{var\"#s5\"} where var\"#s5\"<:Number, PlanPSF}","page":"Methods","title":"SPECTrecon.fft_conv!","text":"fft_conv!(output, img, ker, plan)\n\nConvolve img with ker using FFT, and store the result in output\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv-Tuple{Any, Any}","page":"Methods","title":"SPECTrecon.fft_conv","text":"fft_conv(img, ker)\n\nConvolve img with ker using FFT\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv_adj!-Tuple{AbstractMatrix{var\"#s3\"} where var\"#s3\"<:Number, AbstractMatrix{var\"#s2\"} where var\"#s2\"<:Number, AbstractMatrix{var\"#s80\"} where var\"#s80\"<:Number, PlanPSF}","page":"Methods","title":"SPECTrecon.fft_conv_adj!","text":"fft_conv_adj!(output, img, ker, plan)\n\nAdjoint of convolving img with ker using FFT, and store the result in output\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv_adj-Tuple{Any, Any}","page":"Methods","title":"SPECTrecon.fft_conv_adj","text":"fft_conv_adj(img, ker)\n\nAdjoint of convolving img with ker using FFT\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fftshift2!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T}","page":"Methods","title":"SPECTrecon.fftshift2!","text":"fftshift2!(dst, src)\n\nSame as fftshift in 2d, but non-allocating\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imfilterz!-Tuple{PlanPSF}","page":"Methods","title":"SPECTrecon.imfilterz!","text":"imfilterz!(plan)\n\nFFT-based convolution between plan.img_compl and kernel plan.ker_compl (not centered) putting result in plan.workmat.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate!-Tuple{AbstractArray{var\"#s17\", 3} where var\"#s17\"<:Number, AbstractArray{var\"#s11\", 3} where var\"#s11\"<:Number, Number, Vector{var\"#s6\"} where var\"#s6\"<:PlanRotate}","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, image3, θ, plans)\n\nIn-place version of rotating a 3D image3 by θ in counter-clockwise direction (opposite to imrotate in Julia)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate!-Tuple{AbstractMatrix{var\"#s17\"} where var\"#s17\"<:Number, AbstractMatrix{var\"#s11\"} where var\"#s11\"<:Number, Number, PlanRotate{var\"#s6\", RotateMode{:one}} where var\"#s6\"<:Number}","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, img, θ, plan)\n\nRotate an image by angle θ (must be within 0 to 2π) in counter-clockwise direction (opposite to imrotate in Julia) using 3-pass 1d linear interpolations.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate!-Tuple{AbstractMatrix{var\"#s17\"} where var\"#s17\"<:Number, AbstractMatrix{var\"#s11\"} where var\"#s11\"<:Number, Number, PlanRotate{var\"#s6\", RotateMode{:two}} where var\"#s6\"<:Number}","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, img, θ, plan)\n\nRotate an image by angle θ (must be within 0 to 2π) in counter-clockwise direction (opposite to imrotate in Julia) using 2d bilinear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Number}} where T<:Number","page":"Methods","title":"SPECTrecon.imrotate","text":"imrotate(img, θ; method::Symbol=:two)\n\nRotate an image by angle θ (must be within 0 to 2π) in counter-clockwise direction (opposite to imrotate in Julia) using either 2d linear interpolation (for :two) or 3-pass 1D interpolation (for :one)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj!-Tuple{AbstractArray{var\"#s17\", 3} where var\"#s17\"<:Number, AbstractArray{var\"#s11\", 3} where var\"#s11\"<:Number, Number, Vector{var\"#s6\"} where var\"#s6\"<:PlanRotate}","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, image3, θ, plan)\n\nIn-place version of the adjoint of rotating a 3D image3 by θ in counter-clockwise direction (opposite to imrotate in Julia)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj!-Tuple{AbstractMatrix{var\"#s17\"} where var\"#s17\"<:Number, AbstractMatrix{var\"#s11\"} where var\"#s11\"<:Number, Number, PlanRotate{var\"#s6\", RotateMode{:one}} where var\"#s6\"<:Number}","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, img, θ, plan)\n\nThe adjoint of rotating an image by angle θ (must be within 0 to 2π) in counter-clockwise direction (opposite to imrotate in Julia) using 3-pass 1d linear interpolations.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj!-Tuple{AbstractMatrix{var\"#s17\"} where var\"#s17\"<:Number, AbstractMatrix{var\"#s11\"} where var\"#s11\"<:Number, Number, PlanRotate{var\"#s6\", RotateMode{:two}} where var\"#s6\"<:Number}","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, img, θ, plan)\n\nThe adjoint of rotating an image by angle θ (must be within 0 to 2π) in counter-clockwise direction (opposite to imrotate in Julia) using 2d bilinear interpolations.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Number}} where T<:Number","page":"Methods","title":"SPECTrecon.imrotate_adj","text":"imrotate_adj(img, θ; method::Symbol=:two)\n\nThe adjoint of rotating an image by angle θ (must be within 0 to 2π) in counter-clockwise direction (opposite to imrotate in Julia) using either 2d linear interpolations or 3-pass 1D interpolation.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.linearinterp!-Tuple{LinearInterpolators.SparseInterpolators.SparseInterpolator{var\"#s6\", S, N} where {var\"#s6\"<:AbstractFloat, S, N}, AbstractVector{var\"#s5\"} where var\"#s5\"<:Number}","page":"Methods","title":"SPECTrecon.linearinterp!","text":"linearinterp!(A, x)\n\nAssign key values in SparseInterpolator (linear) A that are calculated from x. x must be a constant vector\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.mul3dj!-Tuple{AbstractArray{var\"#s17\", 3} where var\"#s17\", AbstractMatrix{T} where T, Int64}","page":"Methods","title":"SPECTrecon.mul3dj!","text":"mul3dj!(mat3d, mat2d, j)\n\nNon-allocating mat3d[:,j,:] *= mat2d\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.pad2sizezero!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T} where T, Tuple{Int64, Int64}}} where T","page":"Methods","title":"SPECTrecon.pad2sizezero!","text":"pad2sizezero!(output, img, padsize)\n\nNon-allocating version of padding: `output[paddims[1]+1 : paddims[1]+dims[1],         paddims[2]+1 : paddims[2]+dims[2]]) .= img\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.pad_it!-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{T, D}, Tuple{Vararg{Int64, D}}}} where {D, T<:Number}","page":"Methods","title":"SPECTrecon.pad_it!","text":"pad_it!(X, padsize)\n\nZero-pad X to padsize\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.padrepl!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, NTuple{4, Int64}}","page":"Methods","title":"SPECTrecon.padrepl!","text":"padrepl!(output, img, padsize)\n\nPad with replication from img into output\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.padzero!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T} where T, NTuple{4, Int64}}} where T","page":"Methods","title":"SPECTrecon.padzero!","text":"padzero!(output, img, pad_x, pad_y)\n\nMutating version of padding a 2D image by filling zeros. Output has size (size(img, 1) + padsize[1] + padsize[2], size(img, 2) + padsize[3] + padsize[4]).\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plan_psf-Tuple{Int64, Int64, Int64}","page":"Methods","title":"SPECTrecon.plan_psf","text":"plan_psf(nx::Int, nz::Int, nx_psf::Int; nthread::Int, T::DataType)\n\nMake Vector of structs for storing work arrays and factors for 2D convolution Input\n\nnx::Int\nnz::Int\nnx_psf::Int\n\nOption\n\nT : datatype of work arrays, defaults to Float32\nnthread::Int # of threads, defaults to Threads.nthreads()\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plan_rotate-Tuple{Int64}","page":"Methods","title":"SPECTrecon.plan_rotate","text":"plan_rotate(nx::Int; nthread::Int, T::DataType, method::Symbol)\n\nMake Vector of PlanRotate structs for storing work arrays and factors for 2D square image rotation.\n\nInput\n\nnx::Int must equal to ny\n\nOption\n\nT : datatype of work arrays, defaults to Float32\nmethod::Symbol : default is :two for 2D interpolation; use :one for 3-pass rotation with 1D interpolation\nnthread::Int # of threads, defaults to Threads.nthreads() warning: must use that default currently!\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus1di!-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T, Int64}","page":"Methods","title":"SPECTrecon.plus1di!","text":"plus1di!(mat2d, mat1d)\n\nNon-allocating mat2d[i, :] += mat1d\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus1dj!-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T, Int64}","page":"Methods","title":"SPECTrecon.plus1dj!","text":"plus1dj!(mat2d, mat1d)\n\nNon-allocating mat2d[:, j] += mat1d\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus2di!-Tuple{AbstractVector{T} where T, AbstractMatrix{T} where T, Int64}","page":"Methods","title":"SPECTrecon.plus2di!","text":"plus2di!(mat1d, mat2d, i)\n\nNon-allocating mat1d += mat2d[i,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus2dj!-Tuple{AbstractVector{T} where T, AbstractMatrix{T} where T, Int64}","page":"Methods","title":"SPECTrecon.plus2dj!","text":"plus2dj!(mat1d, mat2d, j)\n\nNon-allocating mat1d += mat2d[:,j]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus3di!-Tuple{AbstractMatrix{T} where T, AbstractArray{var\"#s17\", 3} where var\"#s17\", Int64}","page":"Methods","title":"SPECTrecon.plus3di!","text":"plus3di!(mat2d, mat3d, i)\n\nNon-allocating mat2d += mat3d[i,:,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus3dj!-Tuple{AbstractMatrix{T} where T, AbstractArray{var\"#s17\", 3} where var\"#s17\", Int64}","page":"Methods","title":"SPECTrecon.plus3dj!","text":"plus3dj!(mat2d, mat3d, j)\n\nNon-allocating mat2d += mat3d[:,j,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus3dk!-Tuple{AbstractMatrix{T} where T, AbstractArray{var\"#s17\", 3} where var\"#s17\", Int64}","page":"Methods","title":"SPECTrecon.plus3dk!","text":"plus3dk!(mat2d, mat3d, k)\n\nNon-allocating mat2d += mat3d[:,:,k]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project!-Tuple{AbstractArray{var\"#s11\", 3} where var\"#s11\"<:Number, AbstractArray{var\"#s6\", 3} where var\"#s6\"<:Number, SPECTplan}","page":"Methods","title":"SPECTrecon.project!","text":"project!(views, image, plan; index)\n\nProject image into multiple views with indexes index (defaults to 1:nview). The 3D views array must be pre-allocated, but need not be initialized.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project!-Tuple{AbstractMatrix{var\"#s80\"} where var\"#s80\"<:Number, AbstractArray{var\"#s30\", 3} where var\"#s30\"<:Number, SPECTplan, Int64}","page":"Methods","title":"SPECTrecon.project!","text":"project!(view, plan, image, viewidx)\n\nSPECT projection of image into a single view with index viewidx. The view must be pre-allocated but need not be initialized to zero.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project!-Tuple{AbstractMatrix{var\"#s85\"} where var\"#s85\"<:Number, AbstractArray{var\"#s83\", 3} where var\"#s83\"<:Number, SPECTplan, Int64, Int64}","page":"Methods","title":"SPECTrecon.project!","text":"project!(view, plan, image, thid, viewidx)\n\nSPECT projection of image into a single view with index viewidx. The view must be pre-allocated but need not be initialized to zero.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project-Tuple{AbstractArray{var\"#s19\", 3} where var\"#s19\"<:Number, AbstractArray{var\"#s18\", 3} where var\"#s18\"<:Number, AbstractArray{var\"#s17\", 4} where var\"#s17\"<:Number, Number}","page":"Methods","title":"SPECTrecon.project","text":"views = project(image, mumap, psfs, dy; interpmeth, kwargs...)\n\nConvenience method for SPECT forward projector that does all allocation including initializing plan.\n\nIn\n\nimage : 3D array [nx,ny,nz]\nmumap : [nx,ny,nz] 3D attenuation map, possibly zeros()\npsfs : 4D PSF array\ndy::RealU : pixel size\n\nOption\n\ninterpmeth : :one or :two\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project-Tuple{AbstractArray{var\"#s87\", 3} where var\"#s87\"<:Number, SPECTplan}","page":"Methods","title":"SPECTrecon.project","text":"views = project(image, plan ; kwargs...)\n\nConvenience method for SPECT forward projector that allocates and returns views.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rot180!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T}","page":"Methods","title":"SPECTrecon.rot180!","text":"rot180!(B::AbstractMatrix, A::AbstractMatrix)\n\nIn place version of rot180, returning rotation of A in B.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rot_f90!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, Int64}","page":"Methods","title":"SPECTrecon.rot_f90!","text":"rot_f90!(output, img, m)\n\nIn-place version of rotating an image by 90/180/270 degrees\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rot_f90_adj!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, Int64}","page":"Methods","title":"SPECTrecon.rot_f90_adj!","text":"rot_f90_adj!(output, img, m)\nThe adjoint of rotating an image by 90/180/270 degrees\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_x!-Tuple{AbstractMatrix{var\"#s11\"} where var\"#s11\"<:Number, AbstractMatrix{var\"#s6\"} where var\"#s6\"<:Number, Number, AbstractVector{var\"#s5\"} where var\"#s5\"<:Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_x!","text":"rotate_x!(output, img, tan_θ, workvec, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_x_adj!-Tuple{AbstractMatrix{var\"#s11\"} where var\"#s11\"<:Number, AbstractMatrix{var\"#s6\"} where var\"#s6\"<:Number, Number, AbstractVector{var\"#s5\"} where var\"#s5\"<:Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_x_adj!","text":"rotate_x_adj!(output, img, tan_θ, workvec, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_y!-Tuple{AbstractMatrix{var\"#s11\"} where var\"#s11\"<:Number, AbstractMatrix{var\"#s6\"} where var\"#s6\"<:Number, Number, AbstractVector{var\"#s5\"} where var\"#s5\"<:Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_y!","text":"rotate_y!(output, img, sin_θ, workvec, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_y_adj!-Tuple{AbstractMatrix{var\"#s11\"} where var\"#s11\"<:Number, AbstractMatrix{var\"#s6\"} where var\"#s6\"<:Number, Number, AbstractVector{var\"#s5\"} where var\"#s5\"<:Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_y_adj!","text":"rotate_y_adj!(output, img, sin_θ, workvec, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotl90!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T}","page":"Methods","title":"SPECTrecon.rotl90!","text":"rotl90!(B::AbstractMatrix, A::AbstractMatrix)\n\nIn place version of rotl90, returning rotation of A in B.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotr90!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T}","page":"Methods","title":"SPECTrecon.rotr90!","text":"rotr90!(B::AbstractMatrix, A::AbstractMatrix)\n\nIn place version of rotr90, returning rotation of A in B.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.scale3dj!-Tuple{AbstractMatrix{T} where T, AbstractArray{var\"#s17\", 3} where var\"#s17\", Int64, Number}","page":"Methods","title":"SPECTrecon.scale3dj!","text":"scale3dj!(mat2d, mat3d, j, s)\n\nNon-allocating mat2d = s * mat3d[:,j,:]\n\n\n\n\n\n","category":"method"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"EditURL = \"https://github.com/JeffFessler/SPECTrecon.jl/blob/master/docs/lit/examples/1-overview.jl\"","category":"page"},{"location":"examples/1-overview/#overview","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"This page explains the Julia package SPECTrecon.","category":"page"},{"location":"examples/1-overview/#Setup","page":"SPECTrecon overview","title":"Setup","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Packages needed here.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"using SPECTrecon\nusing MIRTjim: jim, prompt\nusing Plots: scatter, plot!, default; default(markerstrokecolor=:auto)","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"The following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"examples/1-overview/#Overview","page":"SPECTrecon overview","title":"Overview","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"To perform SPECT image reconstruction, one must have a model for the imaging system encapsulated in a forward project and back projector.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"More details todo","category":"page"},{"location":"examples/1-overview/#Units","page":"SPECTrecon overview","title":"Units","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"The pixel dimensions deltas can (and should!) be values with units.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Here is an example ...","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"using UnitfulRecipes\nusing Unitful: mm","category":"page"},{"location":"examples/1-overview/#Methods","page":"SPECTrecon overview","title":"Methods","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"todo","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SPECTrecon","category":"page"},{"location":"#Documentation-for-[SPECTrecon](https://github.com/JeffFessler/SPECTrecon.jl)","page":"Home","title":"Documentation for SPECTrecon","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia module provides SPECT forward and back projectors for parallel-beam collimators, accounting for attenuation and depth-dependent collimator response. (Compton scatter within the object is not modeled.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Designed for use with the Michigan Image Reconstruction Toolbox (MIRT) and similar frameworks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The method implemented here is based on the 1992 paper by GL Zeng & GT Gullberg \"Frequency domain implementation of the three-dimensional geometric point response correction in SPECT imaging\" (IEEE Tr. on Nuclear Science, 39(5-1):1444-53, Oct 1992) (DOI).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The forward projection method works as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The emission image and the attenuation map are rotated (slice by slice) to the desired view angle using either 2D bilinear interpolation or a 3-pass rotation method based on linear interpolation.\nEach (rotated) plane is convolved with the given point spread function (PSF) of the collimator and summed, accounting for attenuation using the \"central ray\" approximation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The back-projection method is the exact adjoint of the forward projector.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Examples tab to the left for usage details.","category":"page"}]
}
