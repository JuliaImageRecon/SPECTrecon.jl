var documenterSearchIndex = {"docs":
[{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"EditURL = \"https://github.com/JeffFessler/SPECTrecon.jl/blob/master/docs/lit/examples/3-psf.jl\"","category":"page"},{"location":"examples/3-psf/#psf","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"","category":"section"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"This page explains the PSF portion of the Julia package SPECTrecon.jl.","category":"page"},{"location":"examples/3-psf/#Setup","page":"SPECTrecon PSF","title":"Setup","text":"","category":"section"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"Packages needed here.","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"using SPECTrecon\nusing MIRTjim: jim, prompt\nusing Plots: scatter, scatter!, plot!, default\ndefault(markerstrokecolor=:auto, markersize=3)","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"The following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"examples/3-psf/#Overview","page":"SPECTrecon PSF","title":"Overview","text":"","category":"section"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"After rotating the image and the attenuation map, second step in SPECT image forward projection is to apply depth-dependent point spread function (PSF). Each (rotated) image plane is a certain distance from the SPECT detector and must be convolved with the 2D PSF appropriate for that plane.","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"Because SPECT has relatively poor spatial resolution, the PSF is usually fairly wide, so convolution using FFT operations is typically more efficient than direct spatial convolution.","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"Following other libraries like FFTW.jl, the PSF operations herein start with a plan where work arrays are preallocated for subsequent use. The plan is a Vector of PlanPSF objects: one for each thread. (Parallelism is across planes for a 3D image volume.) The number of threads defaults to Threads.nthreads().","category":"page"},{"location":"examples/3-psf/#Example","page":"SPECTrecon PSF","title":"Example","text":"","category":"section"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"Start with a 3D image volume.","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"T = Float32 # work with single precision to save memory\nnx = 32\nnz = 30\nimage = zeros(T, nx, nx, nz) # ny = nx required\nimage[1nx÷4, 1nx÷4, 3nz÷4] = 1\nimage[2nx÷4, 2nx÷4, 2nz÷4] = 1\nimage[3nx÷4, 3nx÷4, 1nz÷4] = 1\njim(image, \"Original image\")","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"Create a synthetic gaussian depth-dependent PSF for a single view","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"px = 11\nnview = 1 # for simplicity in this illustration\npsf = repeat(psf_gauss( ; ny, px), 1, 1, 1, nview)\njim(psf, \"PSF for each of $nx planes\")","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"Now plan the PSF modeling by specifying","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"the image size (must be square)\nthe PSF size: must be px × pz × ny × nview\nthe DataType used for the work arrays.","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"plan = plan_psf( ; nx, nz, px, T)","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"Here are the internals for the plan for the first thread:","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"plan[1]","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"With this plan pre-allocated, now we can apply the depth-dependent PSF to the image volume (assumed already rotated here).","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"result = similar(image) # allocate memory for the result\nfft_conv!(result, image, psf[:,:,:,1], plan) # mutates the first argument\njim(result, \"After applying PSF\")","category":"page"},{"location":"examples/3-psf/#Adjoint","page":"SPECTrecon PSF","title":"Adjoint","text":"","category":"section"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"To ensure adjoint consistency between SPECT forward- and back-projection, there is also an adjoint routine:","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"adj = similar(result)\nfft_conv_adj!(adj, result, psf[:,:,:,1], plan)\njim(adj, \"Adjoint of PSF modeling\")","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"The adjoint is not the same as the inverse so one does not expect the output here to match the original image!","category":"page"},{"location":"examples/3-psf/#LinearMap","page":"SPECTrecon PSF","title":"LinearMap","text":"","category":"section"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"One can form a linear map corresponding to PSF modeling using LinearMapAA. Perhaps the main purpose is simply for verifying adjoint correctness.","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"using LinearMapsAA: LinearMapAA\n\nnx, nz, px = 10, 7, 5 # small size for illustration\npsf3 = psf_gauss( ; ny, px)\nplan = plan_psf( ; nx, nz, px, T)\nidim = (nx,nx,nz)\nodim = (nx,nx,nz)\nforw! = (y,x) -> fft_conv!(y, x, psf3, plan)\nback! = (x,y) -> fft_conv_adj!(x, y, psf3, plan)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\n\nAfull = Matrix(A)\nAadj = Matrix(A')\njim(cat(dims=3, Afull, Aadj'), \"Linear map for PSF modeling and its adjoint\")","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"The following check verifies adjoint consistency:","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"@assert Afull ≈ Aadj'","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"","category":"page"},{"location":"examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"EditURL = \"https://github.com/JeffFessler/SPECTrecon.jl/blob/master/docs/lit/examples/2-rotate.jl\"","category":"page"},{"location":"examples/2-rotate/#rotate","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"","category":"section"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"This page explains the image rotation portion of the Julia package SPECTrecon.jl.","category":"page"},{"location":"examples/2-rotate/#Setup","page":"SPECTrecon rotation","title":"Setup","text":"","category":"section"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Packages needed here.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"using SPECTrecon\nusing MIRTjim: jim, prompt\nusing Plots: scatter, scatter!, plot!, default\ndefault(markerstrokecolor=:auto, markersize=3)","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"examples/2-rotate/#Overview","page":"SPECTrecon rotation","title":"Overview","text":"","category":"section"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The first step in SPECT image forward projection is to rotate each slice of a 3D image volume to the appropriate view angle. In principle one could use any of numerous candidate interpolation methods for this task. However, because emission images are nonnegative and maximum likelihood methods for SPECT image reconstruction exploit that nonnegativity, it is desirable to use interpolators that preserve nonnegativity. This constraint rules out quadratic and higher B-splines, including the otherwise attractive cubic B-spline methods. On the other hand, nearest-neighbor interpolation (equivalent to 0th-order B-splines) does not provide adequate image quality. This leaves 1st-order interpolation methods as the most viable options.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"This package supports two 1st-order linear interpolators:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"2D bilinear interpolation,\na 3-pass rotation method based on 1D linear interpolation.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Because image rotation is done repeatedly (for every slice of both the emission image and the attenuation map, for both projection and back-projection, and for multiple iterations), it is important for efficiency to use mutating methods rather than to repeatedly make heap allocations.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Following other libraries like FFTW.jl, the rotation operations herein start with a plan where work arrays are preallocated for subsequent use. The plan is a Vector of PlanRotate objects: one for each thread. (Parallelism is across slices for a 3D image volume.) The number of threads defaults to Threads.nthreads().","category":"page"},{"location":"examples/2-rotate/#Example","page":"SPECTrecon rotation","title":"Example","text":"","category":"section"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Start with a 3D image volume (just 2 slices here for simplicity).","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"T = Float32 # work with single precision to save memory\nimage = zeros(T, 64, 64, 2)\nimage[30:50,20:30,1] .= 1\nimage[25:28,20:40,2] .= 1\njim(image, \"Original image\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Now plan the rotation by specifying","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"the image size nx (it must be square, so ny=nx implicitly)\nthe DataType used for the work arrays.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"plan2 = plan_rotate(size(image, 1); T)","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here are the internals for the plan for the first thread:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"plan2[1]","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"With this plan preallocated, now we can rotate the image volume, specifying the rotation angle in radians:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"result2 = similar(image) # allocate memory for the result\nimrotate!(result2, image, π/6, plan2) # mutates the first argument\njim(result2, \"Rotated image by π/6 (2D bilinear)\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The default, shown above, uses 2D bilinear interpolation for rotation. That default is the recommended approach because it is faster.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here is the 3-pass 1D interpolation approach, included mainly for checking consistency with the historical ASPIRE approach used in Matlab version of MIRT.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"plan1 = plan_rotate(size(image, 1); T, method=:one)","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here are the plan internals for the first thread:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"plan1[1]","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The results of rotation using 3-pass 1D interpolation look quite similar:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"result1 = similar(image)\nimrotate!(result1, image, π/6, plan1)\njim(result1, \"Rotated image by π/6 (3-pass 1D)\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here are the difference images for comparison.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"jim(result1 - result2, \"Difference images\")","category":"page"},{"location":"examples/2-rotate/#Adjoint","page":"SPECTrecon rotation","title":"Adjoint","text":"","category":"section"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"To ensure adjoint consistency between SPECT forward- and back-projection, there is also an adjoint routine:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"adj2 = similar(result2)\nimrotate_adj!(adj2, result2, π/6, plan2)\njim(adj2, \"Adjoint image rotation (2D)\")\n\nadj1 = similar(result1)\nimrotate_adj!(adj1, result1, π/6, plan1)\njim(adj1, \"Adjoint image rotation (3-pass 1D)\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The adjoint is not the same as the inverse so one does not expect the output here to match the original image!","category":"page"},{"location":"examples/2-rotate/#LinearMap","page":"SPECTrecon rotation","title":"LinearMap","text":"","category":"section"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"One can form a linear map corresponding to image rotation using LinearMapAA. An operator like this may be useful as part of a motion-compensated image reconstruction method.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"using LinearMapsAA: LinearMapAA\n\nnx = 20 # small size for illustration\nr1 = plan_rotate(nx; T, nthread = 1, method=:two)[1]\nr2 = plan_rotate(nx; T, nthread = 1, method=:one)[1]\nidim = (nx,nx)\nodim = (nx,nx)\nforw! = (y,x) -> imrotate!(y, x, π/6, r1)\nback! = (x,y) -> imrotate_adj!(x, y, π/6, r1)\nA1 = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\nforw! = (y,x) -> imrotate!(y, x, π/6, r2)\nback! = (x,y) -> imrotate_adj!(x, y, π/6, r2)\nA2 = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\n\nAfull1 = Matrix(A1)\nAadj1 = Matrix(A1')\nAfull2 = Matrix(A2)\nAadj2 = Matrix(A2')\njim(cat(dims=3, Afull1', Aadj1', Afull2', Aadj2'), \"Linear map for 2D rotation and its adjoint\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The following verify adjoint consistency:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"@assert Afull1' ≈ Aadj1\n@assert Afull2' ≈ Aadj2","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Applying this linear map to a 2D or 3D image performs rotation:","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"image2 = zeros(nx,nx); image2[4:6, 5:13] .= 1\njim(cat(dims=3, image2, A2 * image2), \"Rotation via linear map: 2D\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here is 3D too. The A2 * image3 here uses the advanced \"operator\" feature of LinearMapsAA.jl.","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"image3 = cat(dims=3, image2, image2')\njim(cat(dims=4, image3, A2 * image3), \"Rotation via linear map: 3D\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Examine row and column sums of linear map","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"scatter(xlabel=\"pixel index\", ylabel=\"row or col sum\")\nscatter!(vec(sum(Afull1, dims=1)), label=\"dim1 sum1\", marker=:x)\nscatter!(vec(sum(Afull1, dims=2)), label=\"dim2 sum1\", marker=:square)\nscatter!(vec(sum(Afull2, dims=1)), label=\"dim1 sum2\")\nscatter!(vec(sum(Afull2, dims=2)), label=\"dim2 sum2\")","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"","category":"page"},{"location":"examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"history/#History","page":"History","title":"History","text":"","category":"section"},{"location":"history/","page":"History","title":"History","text":"The SPECT forward and back-projection method implemented here is based on the 1992 paper by GL Zeng & GT Gullberg \"Frequency domain implementation of the three-dimensional geometric point response correction in SPECT imaging\" (DOI).","category":"page"},{"location":"history/","page":"History","title":"History","text":"Historically there have been relatively few open-source libraries for SPECT image reconstruction, and to the best of our knowledge source code for the Zeng & Gullberg approach has not been available prior to this package.","category":"page"},{"location":"history/","page":"History","title":"History","text":"Starting in about 1995, the ASPIRE library, developed in the early 1990s at the University of Michigan, began providing precompiled binaries (from C99 source code) for 2D SPECT image reconstruction with documentation.","category":"page"},{"location":"history/","page":"History","title":"History","text":"In about 1997, a 3D version of ASPIRE for SPECT reconstruction became available, again as precompiled binaries with documentation. Anastasia Yendiki was a key contributor to the SPECT code. As noted in a 2001 technical report we took pains to ensure that the forward and back-projector were (adjoint) consistent pairs. Around 2001 the work was extended to consider blob basis functions, leading to a 2004 comparison paper.","category":"page"},{"location":"history/","page":"History","title":"History","text":"Somewhere during that period the 3D SPECT projector / backprojector became available as precompiled MEX files for use with the Matlab version of the Michigan Image Reconstruction Toolbox.","category":"page"},{"location":"history/","page":"History","title":"History","text":"The 3D version in ASPIRE precomputes rotated versions of the attenuation map, to save computation at the price of substantially more memory. That trade-off was reasonable in the era before machine learning. Today, with a focus on end-to-end training of image reconstruction methods in all modalities, including SPECT, it is desirable to have methods that use less memory to facilitate GPU implementations. This open-source Julia package is designed for the machine learning era. ","category":"page"},{"location":"history/","page":"History","title":"History","text":"Development work on this package is supported in part by the following projects led by Dr. Yuni Dewaraja:","category":"page"},{"location":"history/","page":"History","title":"History","text":"NIH Grant R01 EB022075\nNIH Grant R01 CA240706","category":"page"},{"location":"methods/#Methods-list","page":"Methods","title":"Methods list","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"","category":"page"},{"location":"methods/#Methods-usage","page":"Methods","title":"Methods usage","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Modules = [SPECTrecon]","category":"page"},{"location":"methods/#SPECTrecon.SPECTrecon","page":"Methods","title":"SPECTrecon.SPECTrecon","text":"SPECTrecon\n\nSystem matrix (forward and back-projector) for SPECT image reconstruction.\n\n\n\n\n\n","category":"module"},{"location":"methods/#SPECTrecon.Rotate1D","page":"Methods","title":"SPECTrecon.Rotate1D","text":"Rotate1D = RotateMode{:one}()\n\nRotate using 3-pass 1D interpolation\n\n\n\n\n\n","category":"constant"},{"location":"methods/#SPECTrecon.Rotate2D","page":"Methods","title":"SPECTrecon.Rotate2D","text":"Rotate2D = RotateMode{:two}()\n\nRotate using 1-pass 2D bilinear interpolation\n\n\n\n\n\n","category":"constant"},{"location":"methods/#SPECTrecon.PlanPSF","page":"Methods","title":"SPECTrecon.PlanPSF","text":"PlanPSF{T,Tf,Ti}( ; nx::Int, nz::Int, px::Int, pz::Int, T::DataType)\n\nStruct for storing work arrays and factors for 2D convolution for one thread. Each PSF is px × pz\n\nT datatype of work arrays (subtype of AbstractFloat)\nnx::Int = 128 (ny implicitly the same)\nnz::Int = nx image size is [nx,nx,nz]\npx::Int = 1\npz::Int = px (PSF size)\npadsize::Tuple : (padup, paddown, padleft, padright)\nworkmat [nx+padup+paddown, nz+padleft+padright] 2D padded image for FFT convolution\nworkvecx [nx+padup+paddown,]: 1D work vector\nworkvecz [nz+padleft+padright,]: 1D work vector\nimg_compl [nx+padup+paddown, nz+padleft+padright]: 2D [complex] padded image for FFT\nker_compl [nx+padup+paddown, nz+padleft+padright]: 2D [complex] padded image for FFT\nfft_plan::Tf plan for doing FFT; see plan_fft!\nifft_plan::Ti plan for doing IFFT; see plan_ifft!\n\n\n\n\n\n","category":"type"},{"location":"methods/#SPECTrecon.PlanRotate","page":"Methods","title":"SPECTrecon.PlanRotate","text":"PlanRotate{T, R}\n\nStruct for storing work arrays and factors for 2D square image rotation for one thread\n\nT datatype of work arrays (default Float32)\nR::RotateMode\nnx::Int image size\npadsize::Int : pad each side of image by this much\nworkmat1 [nx + 2 * padsize, nx + 2 * padsize] padded work matrix\nworkmat2 [nx + 2 * padsize, nx + 2 * padsize] padded work matrix\ninterp::SparseInterpolator{T, 2, 1}\n\n\n\n\n\n","category":"type"},{"location":"methods/#SPECTrecon.RotateMode","page":"Methods","title":"SPECTrecon.RotateMode","text":"RotateMode\n\nType to control image rotation method.\n\nRotate1D : 3-pass 1D interpolation\nRotate2D : 1-pass 2D bilinear interpolation\n\n\n\n\n\n","category":"type"},{"location":"methods/#SPECTrecon.SPECTplan","page":"Methods","title":"SPECTrecon.SPECTplan","text":"SPECTplan\n\nStruct for storing key factors for a SPECT system model\n\nT datatype of work arrays\nimgsize size of image\npx,pz psf dimension\nimgr [nx, ny, nz] 3D rotated version of image\nadd_img [nx, ny, nz] 3D image for adding views and backprojection\nmumap [nx,ny,nz] attenuation map, must be 3D, possibly zeros()\nmumapr [nx, ny, nz] 3D rotated mumap\nexp_mumapr [nx, nz] 2D exponential rotated mumap\npsfs [px,pz,ny,nview] point spread function, must be 4D, with px andpz` odd, and symmetric for each slice\nnview number of views, must be integer\nviewangle set of view angles, must be from 0 to 2π\ninterpmeth interpolation method, :one means 1d, :two means 2d\nmode pre-allcoation method, :fast means faster, :mem means use less memory\ndy voxel size in y direction (dx is the same value)\nnthread number of CPU threads used to process data, must be integer\nplanrot Vector of struct PlanRotate\nplanpsf Vector of struct PlanPSF\n\nCurrently code assumes the following:\n\neach of the nview projection views is [nx,nz]\nnx = ny\nuniform angular sampling\npsf is symmetric\nmultiprocessing using # of threads specified by Threads.nthreads()\n\n\n\n\n\n","category":"type"},{"location":"methods/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Vector{var\"#s34\"} where var\"#s34\"<:PlanPSF}","page":"Methods","title":"Base.show","text":"show(io::IO, mime::MIME\"text/plain\", vp::Vector{<:PlanPSF})\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Union{Tuple{R}, Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, Array{PlanRotate{T, R, A2} where A2, 1}}} where {T, R}","page":"Methods","title":"Base.show","text":"show(io::IO, mime::MIME\"text/plain\", vp::Vector{<:PlanRotate})\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Union{Tuple{R}, Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, PlanRotate{T, R, A2} where A2}} where {T, R}","page":"Methods","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", plan::PlanRotate)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Union{Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, PlanPSF{T, Tf, Ti} where {Tf, Ti}}} where T","page":"Methods","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", plan::PlanPSF)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Union{Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, SPECTplan{T, A2, A3, A4, U, R} where {A2, A3, A4, U, R}}} where T","page":"Methods","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", plan::SPECTplan)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.sizeof-Tuple{T} where T<:PlanPSF","page":"Methods","title":"Base.sizeof","text":"sizeof(::PlanPSF)\n\nShow size in bytes of PlanPSF object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.sizeof-Tuple{T} where T<:SPECTplan","page":"Methods","title":"Base.sizeof","text":"sizeof(::SPECTplan)\n\nShow size in bytes of SPECTplan object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.sizeof-Tuple{T} where T<:Union{PlanRotate, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"Base.sizeof","text":"sizeof(::PlanRotate)\n\nShow size in bytes of PlanRotate object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject!-Tuple{AbstractArray{var\"#s148\", 3} where var\"#s148\"<:Number, AbstractMatrix{var\"#s83\"} where var\"#s83\"<:Number, SPECTplan, Int64}","page":"Methods","title":"SPECTrecon.backproject!","text":"backproject!(image, view, plan, viewidx)\n\nBackproject a single view.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject!-Tuple{AbstractArray{var\"#s151\", 3} where var\"#s151\"<:Number, AbstractMatrix{var\"#s150\"} where var\"#s150\"<:Number, SPECTplan, Int64, Int64}","page":"Methods","title":"SPECTrecon.backproject!","text":"backproject!(image, view, plan, thid, viewidx)\n\nBackproject a single view.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject!-Tuple{AbstractArray{var\"#s20\", 3} where var\"#s20\"<:Number, AbstractArray{var\"#s19\", 3} where var\"#s19\"<:Number, SPECTplan}","page":"Methods","title":"SPECTrecon.backproject!","text":"backproject!(image, views, plan ; index)\n\nBackproject multiple views into image. Array image is not initialized to zero; caller must do that.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject-Tuple{AbstractArray{var\"#s153\", 3} where var\"#s153\"<:Number, SPECTplan}","page":"Methods","title":"SPECTrecon.backproject","text":"image = backproject(views, plan ; kwargs...)\n\nSPECT backproject views; this allocates the returned 3D array.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject-Tuple{AbstractArray{var\"#s83\", 3} where var\"#s83\"<:Number, AbstractArray{var\"#s34\", 3} where var\"#s34\"<:Number, AbstractArray{var\"#s22\", 4} where var\"#s22\"<:Number, Number}","page":"Methods","title":"SPECTrecon.backproject","text":"image = backproject(views, mumap, psfs, dy; interpmeth, kwargs...)\n\nSPECT backproject views using attenuation map mumap and PSF array psfs for pixel size dy. This method initializes the plan as a convenience. Most users should use backproject! instead after initializing those, for better efficiency.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.copy3dj!-Tuple{AbstractMatrix{T} where T, AbstractArray{var\"#s20\", 3} where var\"#s20\", Int64}","page":"Methods","title":"SPECTrecon.copy3dj!","text":"copy3dj!(mat2d, mat3d, j)\n\nNon-allocating mat2d .= mat3d[:,j,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv!-Tuple{AbstractArray{var\"#s153\", 3} where var\"#s153\"<:Number, AbstractArray{var\"#s152\", 3} where var\"#s152\"<:Number, AbstractArray{var\"#s151\", 3} where var\"#s151\"<:Number, Vector{var\"#s150\"} where var\"#s150\"<:PlanPSF}","page":"Methods","title":"SPECTrecon.fft_conv!","text":"fft_conv!(output, image3, ker3, plans)\n\nMutating version of convolving a 3D image3 with a set of 2D symmetric kernels stored in 3D array ker3 using foreach.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv!-Tuple{AbstractMatrix{var\"#s153\"} where var\"#s153\"<:Number, AbstractMatrix{var\"#s152\"} where var\"#s152\"<:Number, AbstractMatrix{var\"#s151\"} where var\"#s151\"<:Number, PlanPSF}","page":"Methods","title":"SPECTrecon.fft_conv!","text":"fft_conv!(output, img, ker, plan)\n\nConvolve 2D image img with 2D (symmetric!) kernel ker using FFT, storing the result in output.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv-Union{Tuple{K}, Tuple{I}, Tuple{AbstractMatrix{I}, AbstractMatrix{K}}} where {I<:Number, K<:Number}","page":"Methods","title":"SPECTrecon.fft_conv","text":"fft_conv(img, ker; T)\n\nConvolve 2D image img with 2D (symmetric!) kernel ker using FFT.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv_adj!-Tuple{AbstractArray{var\"#s153\", 3} where var\"#s153\"<:Number, AbstractArray{var\"#s152\", 3} where var\"#s152\"<:Number, AbstractArray{var\"#s151\", 3} where var\"#s151\"<:Number, Vector{var\"#s150\"} where var\"#s150\"<:PlanPSF}","page":"Methods","title":"SPECTrecon.fft_conv_adj!","text":"fft_conv_adj!(output, image3, ker3, plans)\n\nAdjoint of fft_conv.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv_adj!-Union{Tuple{T}, Tuple{AbstractMatrix{var\"#s149\"} where var\"#s149\"<:Number, AbstractMatrix{var\"#s148\"} where var\"#s148\"<:Number, AbstractMatrix{var\"#s83\"} where var\"#s83\"<:Number, PlanPSF{T, Tf, Ti} where {Tf, Ti}}} where T","page":"Methods","title":"SPECTrecon.fft_conv_adj!","text":"fft_conv_adj!(output, img, ker, plan)\n\nAdjoint of fft_conv!.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv_adj-Union{Tuple{K}, Tuple{I}, Tuple{AbstractMatrix{I}, AbstractMatrix{K}}} where {I<:Number, K<:Number}","page":"Methods","title":"SPECTrecon.fft_conv_adj","text":"fft_conv_adj(img, ker; T)\n\nAdjoint of fft_conv.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv_adj2!-Tuple{AbstractArray{var\"#s153\", 3} where var\"#s153\"<:Number, AbstractMatrix{var\"#s152\"} where var\"#s152\"<:Number, AbstractArray{var\"#s151\", 3} where var\"#s151\"<:Number, Vector{var\"#s150\"} where var\"#s150\"<:PlanPSF}","page":"Methods","title":"SPECTrecon.fft_conv_adj2!","text":"fft_conv_adj2!(output, image2, ker3, plans)\n\nMutating version of adjoint of convolving a 2D image2 with each 2D kernel in the 3D array ker3.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fftshift2!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T}","page":"Methods","title":"SPECTrecon.fftshift2!","text":"fftshift2!(dst, src)\n\nSame as fftshift in 2d, but non-allocating\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.foreach_setup-Tuple{Any}","page":"Methods","title":"SPECTrecon.foreach_setup","text":" foreach_setup(z)\n\nReturn Channel for foreach threaded computation from iterable z.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imfilterz!-Tuple{PlanPSF}","page":"Methods","title":"SPECTrecon.imfilterz!","text":"imfilterz!(plan)\n\nFFT-based convolution of plan.img_compl and kernel plan.ker_compl (not centered), storing result in plan.workmat.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate!","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, image3, θ, plans, ntasks=nthreads)\n\nIn-place version of rotating a 3D image3 by θ in counter-clockwise direction (opposite to imrotate in Julia) using foreach with ntasks.\n\n\n\n\n\n","category":"function"},{"location":"methods/#SPECTrecon.imrotate!-Tuple{AbstractArray{var\"#s21\", 3} where var\"#s21\"<:Number, AbstractArray{var\"#s20\", 3} where var\"#s20\"<:Number, Number, Vector{var\"#s19\"} where var\"#s19\"<:PlanRotate, Symbol}","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, image3, θ, plans, :thread)\n\nMutating version of rotating a 3D image3 by θ in counter-clockwise direction (opposite of imrotate in Julia) writing result into output, using Threads.@threads.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate!-Tuple{AbstractMatrix{var\"#s20\"} where var\"#s20\"<:Number, AbstractMatrix{var\"#s19\"} where var\"#s19\"<:Number, Number, PlanRotate{var\"#s11\", RotateMode{:one}, A2} where {var\"#s11\"<:Number, A2}}","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, img, θ, plan)\n\nRotate a 2D image img by angle θ ∈ [0,2π] in counter-clockwise direction (opposite to imrotate in Julia) using 3-pass 1d linear interpolations.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate!-Union{Tuple{T}, Tuple{AbstractMatrix{var\"#s21\"} where var\"#s21\"<:Number, AbstractMatrix{var\"#s20\"} where var\"#s20\"<:Number, Number, PlanRotate{T, RotateMode{:two}, A2} where A2}} where T","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, img, θ, plan)\n\nRotate a 2D image img by angle θ ∈ [0,2π] in counter-clockwise direction (opposite to imrotate in Julia) using 2d bilinear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate-Union{Tuple{I}, Tuple{AbstractMatrix{I}, Number}} where I<:Number","page":"Methods","title":"SPECTrecon.imrotate","text":"imrotate(img, θ; method::Symbol=:two)\n\nRotate a 2D image img by angle θ ∈ [0,2π] in counter-clockwise direction (opposite to imrotate in Julia) using either 2d linear interpolation (for :two) or 3-pass 1D interpolation (for :one)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj!","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, image3, θ, plans, ntasks=nthreads)\n\nAdjoint of imrotate! using foreach.\n\n\n\n\n\n","category":"function"},{"location":"methods/#SPECTrecon.imrotate_adj!-Tuple{AbstractArray{var\"#s21\", 3} where var\"#s21\"<:Number, AbstractArray{var\"#s20\", 3} where var\"#s20\"<:Number, Number, Vector{var\"#s19\"} where var\"#s19\"<:PlanRotate, Symbol}","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, image3, θ, plans, :thread)\n\nAdjoint of imrotate! using @threads.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj!-Tuple{AbstractMatrix{var\"#s20\"} where var\"#s20\"<:Number, AbstractMatrix{var\"#s19\"} where var\"#s19\"<:Number, Number, PlanRotate{var\"#s11\", RotateMode{:one}, A2} where {var\"#s11\"<:Number, A2}}","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, img, θ, plan)\n\nAdjoint of imrotate! for a 2D image using 3-pass 1d linear interpolations.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj!-Union{Tuple{T}, Tuple{AbstractMatrix{var\"#s21\"} where var\"#s21\"<:Number, AbstractMatrix{var\"#s20\"} where var\"#s20\"<:Number, Number, PlanRotate{T, RotateMode{:two}, A2} where A2}} where T","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, img, θ, plan)\n\nAdjoint of imrotate! for a 2D image using 2D bilinear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj-Union{Tuple{I}, Tuple{AbstractMatrix{I}, Number}} where I<:Number","page":"Methods","title":"SPECTrecon.imrotate_adj","text":"imrotate_adj(img, θ; method::Symbol=:two)\n\nAdjoint of rotating a 2D image img by angle θ ∈ [0,2π] in counter-clockwise direction (opposite to imrotate in Julia) using either 2d linear interpolations or 3-pass 1D interpolation.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.linearinterp!-Tuple{LinearInterpolators.SparseInterpolators.SparseInterpolator{var\"#s19\", S, N} where {var\"#s19\"<:AbstractFloat, S, N}, Number, Number, Int64}","page":"Methods","title":"SPECTrecon.linearinterp!","text":"linearinterp!(A, s, e, len)\n\nAssign key values in SparseInterpolator (linear) A that are calculated from s, e and len. s means start (x[1]) e means end (x[end]) len means length (length(x))\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.mul3dj!-Tuple{AbstractArray{var\"#s20\", 3} where var\"#s20\", AbstractMatrix{T} where T, Int64}","page":"Methods","title":"SPECTrecon.mul3dj!","text":"mul3dj!(mat3d, mat2d, j)\n\nNon-allocating mat3d[:,j,:] *= mat2d\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.pad2sizezero!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T} where T, Tuple{Int64, Int64}}} where T","page":"Methods","title":"SPECTrecon.pad2sizezero!","text":"pad2sizezero!(output, img, padsize)\n\nNon-allocating version of padding: `output[paddims[1]+1 : paddims[1]+dims[1],         paddims[2]+1 : paddims[2]+dims[2]]) .= img\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.pad_it!-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{T, D}, Tuple{Vararg{Int64, D}}}} where {D, T<:Number}","page":"Methods","title":"SPECTrecon.pad_it!","text":"pad_it!(X, padsize)\n\nZero-pad X to padsize\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.padrepl!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, NTuple{4, Int64}}","page":"Methods","title":"SPECTrecon.padrepl!","text":"padrepl!(output, img, padsize)\n\nPad with replication from img into output\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.padzero!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T} where T, NTuple{4, Int64}}} where T","page":"Methods","title":"SPECTrecon.padzero!","text":"padzero!(output, img, pad_x, pad_y)\n\nMutating version of padding a 2D image by filling zeros. Output has size (size(img, 1) + padsize[1] + padsize[2], size(img, 2) + padsize[3] + padsize[4]).\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plan_psf-Tuple{}","page":"Methods","title":"SPECTrecon.plan_psf","text":"plan_psf( ; nx::Int, nz::Int, px::Int, pz::Int, nthread::Int, T::DataType)\n\nMake Vector of structs for storing work arrays and factors for 2D convolution with SPECT depth-dependent PSF model, threaded across planes parallel to detector. Option\n\nnx::Int = 128\nnz::Int = nx\npx::Int = 1\npz::Int = px PSF size is px × pz\nT : datatype of work arrays, defaults to Float32\nnthread::Int # of threads, defaults to Threads.nthreads()\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plan_rotate-Tuple{Int64}","page":"Methods","title":"SPECTrecon.plan_rotate","text":"plan_rotate(nx::Int; T::DataType, method::Symbol)\n\nMake Vector of PlanRotate structs for storing work arrays and factors for threaded rotation of a stack of 2D square images.\n\nInput\n\nnx::Int must equal to ny (square images only)\n\nOption\n\nT : datatype of work arrays, defaults to Float32\nmethod::Symbol : default is :two for 2D interpolation; use :one for 3-pass rotation with 1D interpolation\nnthread::Int : default to Threads.nthreads() The other useful option is 1 when rotating just one image.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus1di!-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T, Int64}","page":"Methods","title":"SPECTrecon.plus1di!","text":"plus1di!(mat2d, mat1d)\n\nNon-allocating mat2d[i, :] += mat1d\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus1dj!-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T, Int64}","page":"Methods","title":"SPECTrecon.plus1dj!","text":"plus1dj!(mat2d, mat1d)\n\nNon-allocating mat2d[:, j] += mat1d\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus2di!-Tuple{AbstractVector{T} where T, AbstractMatrix{T} where T, Int64}","page":"Methods","title":"SPECTrecon.plus2di!","text":"plus2di!(mat1d, mat2d, i)\n\nNon-allocating mat1d += mat2d[i,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus2dj!-Tuple{AbstractVector{T} where T, AbstractMatrix{T} where T, Int64}","page":"Methods","title":"SPECTrecon.plus2dj!","text":"plus2dj!(mat1d, mat2d, j)\n\nNon-allocating mat1d += mat2d[:,j]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus3di!-Tuple{AbstractMatrix{T} where T, AbstractArray{var\"#s20\", 3} where var\"#s20\", Int64}","page":"Methods","title":"SPECTrecon.plus3di!","text":"plus3di!(mat2d, mat3d, i)\n\nNon-allocating mat2d += mat3d[i,:,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus3dj!-Tuple{AbstractMatrix{T} where T, AbstractArray{var\"#s20\", 3} where var\"#s20\", Int64}","page":"Methods","title":"SPECTrecon.plus3dj!","text":"plus3dj!(mat2d, mat3d, j)\n\nNon-allocating mat2d += mat3d[:,j,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus3dk!-Tuple{AbstractMatrix{T} where T, AbstractArray{var\"#s20\", 3} where var\"#s20\", Int64}","page":"Methods","title":"SPECTrecon.plus3dk!","text":"plus3dk!(mat2d, mat3d, k)\n\nNon-allocating mat2d += mat3d[:,:,k]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project!-Tuple{AbstractArray{var\"#s21\", 3} where var\"#s21\"<:Number, AbstractArray{var\"#s20\", 3} where var\"#s20\"<:Number, SPECTplan}","page":"Methods","title":"SPECTrecon.project!","text":"project!(views, image, plan; index)\n\nProject image into multiple views with indexes index (defaults to 1:nview). The 3D views array must be pre-allocated, but need not be initialized.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project!-Tuple{AbstractMatrix{var\"#s149\"} where var\"#s149\"<:Number, AbstractArray{var\"#s148\", 3} where var\"#s148\"<:Number, SPECTplan, Int64}","page":"Methods","title":"SPECTrecon.project!","text":"project!(view, plan, image, viewidx)\n\nSPECT projection of image into a single view with index viewidx. The view must be pre-allocated but need not be initialized to zero.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project!-Tuple{AbstractMatrix{var\"#s151\"} where var\"#s151\"<:Number, AbstractArray{var\"#s150\", 3} where var\"#s150\"<:Number, SPECTplan, Int64, Int64}","page":"Methods","title":"SPECTrecon.project!","text":"project!(view, plan, image, thid, viewidx)\n\nSPECT projection of image into a single view with index viewidx. The view must be pre-allocated but need not be initialized to zero.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project-Tuple{AbstractArray{var\"#s153\", 3} where var\"#s153\"<:Number, SPECTplan}","page":"Methods","title":"SPECTrecon.project","text":"views = project(image, plan ; kwargs...)\n\nConvenience method for SPECT forward projector that allocates and returns views.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project-Tuple{AbstractArray{var\"#s83\", 3} where var\"#s83\"<:Number, AbstractArray{var\"#s34\", 3} where var\"#s34\"<:Number, AbstractArray{var\"#s22\", 4} where var\"#s22\"<:Number, Number}","page":"Methods","title":"SPECTrecon.project","text":"views = project(image, mumap, psfs, dy; interpmeth, kwargs...)\n\nConvenience method for SPECT forward projector that does all allocation including initializing plan.\n\nIn\n\nimage : 3D array (nx,ny,nz)\nmumap : (nx,ny,nz) 3D attenuation map, possibly zeros()\npsfs : 4D PSF array\ndy::RealU : pixel size\n\nOption\n\ninterpmeth : :one or :two\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.psf_gauss-Tuple{}","page":"Methods","title":"SPECTrecon.psf_gauss","text":"psf_gauss( ; ny, px, pz, fwhm_start, fwhm_end, fwhm, fwhm_x, fwhm_z, T)\n\nCreate depth-dependent Gaussian PSFs having specified full-width half-maximum (FHWM) values.\n\nOptions\n\n'ny::Int = 128'\n'px::Int = 11' (should be odd)\n'pz::Int = px' (should be odd)\n'fwhm_start::Real = 1'\n'fwhm_end::Real = 4'\n'fwhm::AbstractVector{<:Real} = LinRange(fwhmstart, fwhmend, ny)'\n'fwhm_x::AbstractVector{<:Real} = fwhm,\n'fwhmz::AbstractVector{<:Real} = fwhmx'\n'T::DataType == Float32'\n\nReturned psf is [px, pz, ny] where each PSF sums to 1.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rot180!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T}","page":"Methods","title":"SPECTrecon.rot180!","text":"rot180!(B::AbstractMatrix, A::AbstractMatrix)\n\nIn place version of rot180, returning rotation of A in B.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rot_f90!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, Int64}","page":"Methods","title":"SPECTrecon.rot_f90!","text":"rot_f90!(output, img, m)\n\nIn-place version of rotating an image by 90/180/270 degrees\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rot_f90_adj!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, Int64}","page":"Methods","title":"SPECTrecon.rot_f90_adj!","text":"rot_f90_adj!(output, img, m)\nThe adjoint of rotating an image by 90/180/270 degrees\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_x!-Tuple{AbstractMatrix{var\"#s20\"} where var\"#s20\"<:Number, AbstractMatrix{var\"#s19\"} where var\"#s19\"<:Number, Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_x!","text":"rotate_x!(output, img, tan_θ, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_x_adj!-Tuple{AbstractMatrix{var\"#s20\"} where var\"#s20\"<:Number, AbstractMatrix{var\"#s19\"} where var\"#s19\"<:Number, Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_x_adj!","text":"rotate_x_adj!(output, img, tan_θ, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_y!-Tuple{AbstractMatrix{var\"#s20\"} where var\"#s20\"<:Number, AbstractMatrix{var\"#s19\"} where var\"#s19\"<:Number, Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_y!","text":"rotate_y!(output, img, sin_θ, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_y_adj!-Tuple{AbstractMatrix{var\"#s20\"} where var\"#s20\"<:Number, AbstractMatrix{var\"#s19\"} where var\"#s19\"<:Number, Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_y_adj!","text":"rotate_y_adj!(output, img, sin_θ, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotl90!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T}","page":"Methods","title":"SPECTrecon.rotl90!","text":"rotl90!(B::AbstractMatrix, A::AbstractMatrix)\n\nIn place version of rotl90, returning rotation of A in B.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotr90!-Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T}","page":"Methods","title":"SPECTrecon.rotr90!","text":"rotr90!(B::AbstractMatrix, A::AbstractMatrix)\n\nIn place version of rotr90, returning rotation of A in B.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.scale3dj!-Tuple{AbstractMatrix{T} where T, AbstractArray{var\"#s20\", 3} where var\"#s20\", Int64, Number}","page":"Methods","title":"SPECTrecon.scale3dj!","text":"scale3dj!(mat2d, mat3d, j, s)\n\nNon-allocating mat2d = s * mat3d[:,j,:]\n\n\n\n\n\n","category":"method"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"EditURL = \"https://github.com/JeffFessler/SPECTrecon.jl/blob/master/docs/lit/examples/1-overview.jl\"","category":"page"},{"location":"examples/1-overview/#overview","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"This page gives an overview of the Julia package SPECTrecon.","category":"page"},{"location":"examples/1-overview/#Setup","page":"SPECTrecon overview","title":"Setup","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Packages needed here.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"using SPECTrecon\nusing MIRTjim: jim, prompt\nusing LinearAlgebra: mul!\nusing LinearMapsAA: LinearMapAA\nusing Plots: scatter, plot!, default; default(markerstrokecolor=:auto)\nusing Plots # @animate, gif","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"The following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"examples/1-overview/#Overview","page":"SPECTrecon overview","title":"Overview","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"To perform SPECT image reconstruction, one must have a model for the imaging system encapsulated in a forward projector and back projector.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Mathematically, we write the forward projection process in SPECT as \"y = A * x\" where A is a \"system matrix\" that models the physics of the imaging system (including depth-dependent collimator/detector response and attenuation) and \"x\" is the current guess of the emission image.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"However, in code we usually cannot literally store \"A\" as dense matrix because it is too large. A typical size in SPECT is that the image x is nx × ny × nz = 128 × 128 × 100 and the array of projection views y is nx × nz × nview = 128 × 100 × 120. So the system matrix A has 1536000 × 1638400 elements which is far to many to store, even accounting for some sparsity.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Instead, we write functions called forward projectors that calculate A * x \"on the fly\".","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Similarly, the operation A' * y is called \"back projection\", where A' denotes the transpose or \"adjoint\" of A.","category":"page"},{"location":"examples/1-overview/#Example","page":"SPECTrecon overview","title":"Example","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"To illustrate forward and back projection, it is easiest to start with a simulation example using a digital phantom. The fancy way would be to use a 3D phantom from ImagePhantoms, but instead we just use two simple cubes.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"nx,ny,nz = 128,128,80\nT = Float32\nxtrue = zeros(T, nx,ny,nz)\nxtrue[(1nx÷4):(2nx÷3), 1ny÷5:(3ny÷5), 2nz÷6:(3nz÷6)] .= 1\nxtrue[(2nx÷5):(3nx÷5), 1ny÷5:(2ny÷5), 4nz÷6:(5nz÷6)] .= 2\n\naverage(x) = sum(x) / length(x)\nfunction mid3(x::AbstractArray{T,3}) where {T}\n    (nx,ny,nz) = size(x)\n    xy = x[:,:,ceil(Int, nz÷2)]\n    xz = x[:,ceil(Int,end/2),:]\n    zy = x[ceil(Int, nx÷2),:,:]'\n    return [xy xz; zy fill(average(x), nz, nz)]\nend\njim(mid3(xtrue), \"Middle slices of x\")","category":"page"},{"location":"examples/1-overview/#PSF","page":"SPECTrecon overview","title":"PSF","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Create a synthetic depth-dependent PSF for a single view","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"px = 11\npsf1 = psf_gauss( ; ny, px, fwhm_end = 6)\njim(psf1, \"PSF for each of $ny planes\")","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"In general the PSF can vary from view to view due to non-circular detector orbits. For simplicity, here we illustrate the case where the PSF is the same for every view.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"nview = 60\npsfs = repeat(psf1, 1, 1, 1, nview)\nsize(psfs)","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Plan the PSF modeling (see 3-psf.jl)","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"plan = plan_psf( ; nx, nz, px)","category":"page"},{"location":"examples/1-overview/#Basic-SPECT-forward-projection","page":"SPECTrecon overview","title":"Basic SPECT forward projection","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Here is a simple illustration of a SPECT forward projection operation. (This is a memory inefficient way to do it!)","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"dy = 4 # transaxial pixel size in mm\nmumap = zeros(T, size(xtrue)) # μ-map just zero for illustration here\nviews = project(xtrue, mumap, psfs, dy)\nsize(views)","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Display the calculated (i.e., simulated) projection views","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"jim(views[:,:,1:4:end], \"Every 4th of $nview projection views\")","category":"page"},{"location":"examples/1-overview/#Basic-SPECT-back-projection","page":"SPECTrecon overview","title":"Basic SPECT back projection","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"This illustrates an \"unfiltered backprojection\" that leads to a very blurry image (again, with a simple memory inefficient usage).","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"First, back-project two \"rays\" to illustrate the depth-dependent PSF.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"tmp = zeros(T, size(views))\ntmp[nx÷2, nz÷2, nview÷5] = 1\ntmp[nx÷2, nz÷2, 1] = 1\ntmp = backproject(tmp, mumap, psfs, dy)\njim(mid3(tmp), \"Back-projection of two rays\")","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Now back-project all the views of the phantom.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"back = backproject(views, mumap, psfs, dy)\njim(mid3(back), \"Back-projection of ytrue\")","category":"page"},{"location":"examples/1-overview/#Memory-efficiency","page":"SPECTrecon overview","title":"Memory efficiency","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"For iterative reconstruction, one must do forward and back-projection repeatedly. It is more efficient to pre-allocate work arrays for those operations, instead of repeatedly making system calls.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Here we illustrate the memory efficient versions that are recommended for iterative SPECT reconstruction.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"First construction the SPECT plan.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"#viewangle = (0:(nview-1)) * 2π # default\nplan = SPECTplan(mumap, psfs, dy; T)","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Mutating version of forward projection:","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"tmp = Array{T}(undef, nx, nz, nview)\nproject!(tmp, xtrue, plan)\n@assert tmp == views","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Mutating version of back-projection:","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"tmp = Array{T}(undef, nx, ny, nz)\nbackproject!(tmp, views, plan)\n@assert tmp == back","category":"page"},{"location":"examples/1-overview/#Using-LinearMapAA","page":"SPECTrecon overview","title":"Using LinearMapAA","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Calling project! and backproject! repeatedly leads to application-specific code. More general code uses the fact that SPECT projection and back-projection are linear operations, so we use LinearMapAA to define a \"system matrix\" for these operations.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"forw! = (y,x) -> project!(y, x, plan)\nback! = (x,y) -> backproject!(x, y, plan)\nidim = (nx,ny,nz)\nodim = (nx,nz,nview)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Simple forward and back-projection:","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"@assert A * xtrue == views\n@assert A' * views == back","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Mutating version:","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"tmp = Array{T}(undef, nx, nz, nview)\nmul!(tmp, A, xtrue)\n@assert tmp == views\ntmp = Array{T}(undef, nx, ny, nz)\nmul!(tmp, A', views)\n@assert tmp == back","category":"page"},{"location":"examples/1-overview/#Units","page":"SPECTrecon overview","title":"Units","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"The pixel dimensions deltas can (and should!) be values with units.","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Here is an example ... (todo)","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"#using UnitfulRecipes\n#using Unitful: mm","category":"page"},{"location":"examples/1-overview/#Projection-view-animation","page":"SPECTrecon overview","title":"Projection view animation","text":"","category":"section"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"anim = @animate for i in 1:nview\n    ymax = maximum(views)\n    jim(views[:,:,i],\n        \"SPECT projection view $i of $nview\",\n        clim = (0, ymax),\n    )\nend\ngif(anim, \"views.gif\", fps = 8)","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"","category":"page"},{"location":"examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SPECTrecon","category":"page"},{"location":"#Documentation-for-[SPECTrecon](https://github.com/JeffFessler/SPECTrecon.jl)","page":"Home","title":"Documentation for SPECTrecon","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia module provides SPECT forward and back projectors for parallel-beam collimators, accounting for attenuation and depth-dependent collimator response. (Compton scatter within the object is not modeled.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Designed for use with the Michigan Image Reconstruction Toolbox (MIRT) and similar frameworks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The method implemented here is based on the 1992 paper by GL Zeng & GT Gullberg \"Frequency domain implementation of the three-dimensional geometric point response correction in SPECT imaging\" (IEEE Tr. on Nuclear Science, 39(5-1):1444-53, Oct 1992) (DOI).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The forward projection method works as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The emission image and the attenuation map are rotated (slice by slice) to the desired view angle using either 2D bilinear interpolation or a 3-pass rotation method based on linear interpolation.\nEach (rotated) plane is convolved with the given point spread function (PSF) of the collimator and summed, accounting for attenuation using the \"central ray\" approximation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The back-projection method is the exact adjoint of the forward projector.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Examples tab to the left for usage details.","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"EditURL = \"https://github.com/JeffFessler/SPECTrecon.jl/blob/master/docs/lit/examples/4-mlem.jl\"","category":"page"},{"location":"examples/4-mlem/#mlem","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"","category":"section"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"This page illustrates ML-EM reconstruction with the Julia package SPECTrecon.","category":"page"},{"location":"examples/4-mlem/#Setup","page":"SPECTrecon ML-EM","title":"Setup","text":"","category":"section"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"Packages needed here.","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"using SPECTrecon\nusing MIRTjim: jim, prompt\nusing Plots: scatter, plot!, default; default(markerstrokecolor=:auto)","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"The following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"examples/4-mlem/#Overview","page":"SPECTrecon ML-EM","title":"Overview","text":"","category":"section"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"Maximum-likelihood expectation-maximization (ML-EM) is a classic algorithm for performing SPECT image reconstruction.","category":"page"},{"location":"examples/4-mlem/#Simulation-data","page":"SPECTrecon ML-EM","title":"Simulation data","text":"","category":"section"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"nx,ny,nz = 64,64,50\nT = Float32\nxtrue = zeros(T, nx,ny,nz)\nxtrue[(1nx÷4):(2nx÷3), 1ny÷5:(3ny÷5), 2nz÷6:(3nz÷6)] .= 1\nxtrue[(2nx÷5):(3nx÷5), 1ny÷5:(2ny÷5), 4nz÷6:(5nz÷6)] .= 2\n\naverage(x) = sum(x) / length(x)\nfunction mid3(x::AbstractArray{T,3}) where {T}\n    (nx,ny,nz) = size(x)\n    xy = x[:,:,ceil(Int, nz÷2)]\n    xz = x[:,ceil(Int,end/2),:]\n    zy = x[ceil(Int, nx÷2),:,:]'\n    return [xy xz; zy fill(average(xy), nz, nz)]\nend\njim(mid3(xtrue), \"Middle slices of xtrue\")","category":"page"},{"location":"examples/4-mlem/#PSF","page":"SPECTrecon ML-EM","title":"PSF","text":"","category":"section"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"Create a synthetic depth-dependent PSF for a single view","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"px = 11\npsf1 = psf_gauss( ; ny, px)\njim(psf1, \"PSF for each of $ny planes\")","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"In general the PSF can vary from view to view due to non-circular detector orbits. For simplicity, here we illustrate the case where the PSF is the same for every view.","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"nview = 60\npsfs = repeat(psf1, 1, 1, 1, nview)\nsize(psfs)","category":"page"},{"location":"examples/4-mlem/#SPECT-system-model-using-LinearMapAA","page":"SPECTrecon ML-EM","title":"SPECT system model using LinearMapAA","text":"","category":"section"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"dy = 8 # transaxial pixel size in mm\nmumap = zeros(T, size(xtrue)) # zero μ-map just for illustration here\nplan = SPECTplan(mumap, psfs, dy; T)\n\nusing LinearMapsAA: LinearMapAA\nusing LinearAlgebra: mul!\nforw! = (y,x) -> project!(y, x, plan)\nback! = (x,y) -> backproject!(x, y, plan)\nidim = (nx,ny,nz)\nodim = (nx,nz,nview)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)","category":"page"},{"location":"examples/4-mlem/#Basic-Expectation-Maximization-(EM)-algorithm","page":"SPECTrecon ML-EM","title":"Basic Expectation-Maximization (EM) algorithm","text":"","category":"section"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"Noisy data","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"using Distributions: Poisson\n\nif !@isdefined(ynoisy) # generate (scaled) Poisson data\n    ytrue = A * xtrue\n    target_mean = 20 # aim for mean of 20 counts per ray\n    scale = target_mean / average(ytrue)\n    scatter_fraction = 0.1 # 10% uniform scatter for illustration\n    scatter_mean = scatter_fraction * average(ytrue) # uniform for simplicity\n    ynoisy = rand.(Poisson.(scale * (ytrue .+ scatter_mean))) / scale\nend\njim(ynoisy, \"$nview noisy projection views\")","category":"page"},{"location":"examples/4-mlem/#ML-EM-algorithm-basic-version","page":"SPECTrecon ML-EM","title":"ML-EM algorithm - basic version","text":"","category":"section"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"This basic ML-EM version uses the linear map, but it is still allocating.","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"function mlem(x0, ynoisy, background, A; niter::Int = 20)\n    all(>(0), background) || throw(\"need background > 0\")\n    x = copy(x0)\n    asum = A' * ones(eltype(ynoisy), size(ynoisy))\n\ttime0 = time()\n    for iter = 1:niter\n        @show iter, extrema(x), time() - time0\n        ybar = A * x .+ background # forward model\n        x .*= (A' * (ynoisy ./ ybar)) ./ asum # multiplicative update\n    end\n    return x\nend","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"This preferable ML-EM version modifies the input x, so no memory allocation is needed within the loop!","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"function mlem!(x, ynoisy, background, A; niter::Int = 20)\n    all(>(0), background) || throw(\"need background > 0\")\n    asum = A' * ones(eltype(ynoisy), size(ynoisy)) # this allocates\n    ybar = similar(ynoisy)\n    yratio = similar(ynoisy)\n    back = similar(x)\n\ttime0 = time()\n    for iter = 1:niter\n        @show iter, extrema(x), time() - time0\n        mul!(ybar, A, x)\n        @. yratio = ynoisy / (ybar + background) # coalesce broadcast!\n        mul!(back, A', yratio) # back = A' * (ynoisy / ybar)\n        @. x *= back / asum # multiplicative update\n    end\n    return x\nend","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"Apply both versions of ML-EM to this simulated data","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"x0 = ones(T, nx, ny, nz) # initial uniform image\n\nniter = 30\nif !@isdefined(xhat1)\n    xhat1 = mlem(x0, ynoisy, scatter_mean, A; niter)\nend\n\nif !@isdefined(xhat2)\n    xhat2 = copy(x0)\n    mlem!(xhat2, ynoisy, scatter_mean, A; niter)\nend\n\n@assert xhat1 ≈ xhat2\n\njim(mid3(xhat2), \"ML-EM at $niter iterations\")","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"","category":"page"},{"location":"examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"EditURL = \"https://github.com/JeffFessler/SPECTrecon.jl/blob/master/docs/lit/examples/5-2d.jl\"","category":"page"},{"location":"examples/5-2d/#2d","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"","category":"section"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"This page describes how to perform 2D SPECT forward and back-projection using the Julia package SPECTrecon.","category":"page"},{"location":"examples/5-2d/#Setup","page":"SPECTrecon 2D use","title":"Setup","text":"","category":"section"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Packages needed here.","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"using SPECTrecon\nusing MIRTjim: jim, prompt\nusing ImagePhantoms: shepp_logan, SheppLoganEmis\nusing LinearAlgebra: mul!\nusing LinearMapsAA: LinearMapAA\nusing Plots: plot, default; default(markerstrokecolor=:auto)","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"The following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"examples/5-2d/#Overview","page":"SPECTrecon 2D use","title":"Overview","text":"","category":"section"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Real SPECT systems are inherently 3D imaging systems, but for the purpose of prototyping algorithms it can be useful to work with 2D simulations.","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Currently, \"2D\" here means a 3D array with nz=1, i.e., a single slice. The key to working with a single slice is that the package allows the PSFs to have rectangular support px × pz where pz = 1, i.e., no blur along the axial (z) direction.","category":"page"},{"location":"examples/5-2d/#Example","page":"SPECTrecon 2D use","title":"Example","text":"","category":"section"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Start with a simple 2D digital phantom.","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"T = Float32\nnx,ny,nz = 128,128,1\nxtrue = T.(shepp_logan(nx, SheppLoganEmis()))\nxtrue = reshape(xtrue, nx, ny, 1) # 3D array with nz=1\njim(xtrue, \"xtrue: SheppLoganEmis with size $(size(xtrue))\")","category":"page"},{"location":"examples/5-2d/#PSF","page":"SPECTrecon 2D use","title":"PSF","text":"","category":"section"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Create a synthetic depth-dependent PSF for a single view","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"px,pz = 11,1 # pz=1 is crucial for 2D work\npsf1 = psf_gauss( ; ny, px, pz, fwhm_start = 1, fwhm_end = 4) # (px,pz,ny)\ntmp = reshape(psf1, px, ny) / maximum(psf1) # (px,ny)\nhx = (px-1)÷2\nplot(-hx:hx, tmp[:,[1:9:end-10;end]], markershape=:o, label=\"\",\n    title = \"Depth-dependent PSF profiles\",\n    xtick = [-hx, -2, 0, 2, hx], # (-1:1) .* ((px-1)÷2),\n    ytick = [0; round.(tmp[hx+1,end] * [0.5,1], digits=2); 0.5; 1],\n)\nprompt()","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"In general the PSF can vary from view to view due to non-circular detector orbits. For simplicity, here we illustrate the case where the PSF is the same for every view.","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"nview = 80\npsfs = repeat(psf1, 1, 1, 1, nview)\nsize(psfs)","category":"page"},{"location":"examples/5-2d/#Basic-SPECT-forward-projection","page":"SPECTrecon 2D use","title":"Basic SPECT forward projection","text":"","category":"section"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Here is a simple illustration of a SPECT forward projection operation. (This is a memory inefficient way to do it!)","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"dy = 4 # transaxial pixel size in mm\nmumap = zeros(T, size(xtrue)) # μ-map just zero for illustration here\nviews = project(xtrue, mumap, psfs, dy) # [nx,1,nview]\nsino = reshape(views, nx, nview)\nsize(sino)","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Display the calculated (i.e., simulated) projection views","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"jim(sino, \"Sinogram\")","category":"page"},{"location":"examples/5-2d/#Basic-SPECT-back-projection","page":"SPECTrecon 2D use","title":"Basic SPECT back projection","text":"","category":"section"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"This illustrates an \"unfiltered backprojection\" that leads to a very blurry image (again, with a simple memory inefficient usage).","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"First, back-project two \"rays\" to illustrate the depth-dependent PSF.","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"sino1 = zeros(T, nx, nview)\nsino1[nx÷2, nview÷5] = 1\nsino1[nx÷2, 1] = 1\nsino1 = reshape(sino1, nx, nz, nview)\nback1 = backproject(sino1, mumap, psfs, dy)\njim(back1, \"Back-projection of two rays\")","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Now back-project all the views of the phantom.","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"back = backproject(views, mumap, psfs, dy)\njim(back, \"Back-projection of ytrue\")","category":"page"},{"location":"examples/5-2d/#Memory-efficiency","page":"SPECTrecon 2D use","title":"Memory efficiency","text":"","category":"section"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"For iterative reconstruction, one must do forward and back-projection repeatedly. It is more efficient to pre-allocate work arrays for those operations, instead of repeatedly making system calls.","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Here we illustrate the memory efficient versions that are recommended for iterative SPECT reconstruction.","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"First construction the SPECT plan.","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"#viewangle = (0:(nview-1)) * 2π # default\nplan = SPECTplan(mumap, psfs, dy; T)","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Mutating version of forward projection:","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"tmp = Array{T}(undef, nx, nz, nview)\nproject!(tmp, xtrue, plan)\n@assert tmp == views","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Mutating version of back-projection:","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"tmp = Array{T}(undef, nx, ny, nz)\nbackproject!(tmp, views, plan)\n@assert tmp == back","category":"page"},{"location":"examples/5-2d/#Using-LinearMapsAA","page":"SPECTrecon 2D use","title":"Using LinearMapsAA","text":"","category":"section"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Calling project! and backproject! repeatedly leads to application-specific code. More general code uses the fact that SPECT projection and back-projection are linear operations, so we use LinearMapAA to define a \"system matrix\" for these operations.","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"forw! = (y,x) -> project!(y, x, plan)\nback! = (x,y) -> backproject!(x, y, plan)\nidim = (nx,ny,nz)\nodim = (nx,nz,nview)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Simple forward and back-projection:","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"@assert A * xtrue == views\n@assert A' * views == back","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Mutating version:","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"tmp = Array{T}(undef, nx, nz, nview)\nmul!(tmp, A, xtrue)\n@assert tmp == views\ntmp = Array{T}(undef, nx, ny, nz)\nmul!(tmp, A', views)\n@assert tmp == back","category":"page"},{"location":"examples/5-2d/#Gram-matrix-impulse-response","page":"SPECTrecon 2D use","title":"Gram matrix impulse response","text":"","category":"section"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"points = zeros(T, nx, ny, nz)\npoints[nx÷2,ny÷2,1] = 1\npoints[3nx÷4,ny÷4,1] = 1\n\nimpulse = A' * (A * points)\njim(impulse, \"Impulse response of A'A\")","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"","category":"page"},{"location":"examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"This page was generated using Literate.jl.","category":"page"}]
}
