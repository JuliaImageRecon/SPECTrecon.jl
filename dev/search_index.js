var documenterSearchIndex = {"docs":
[{"location":"generated/examples/5-2d/#5-2d","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"This page describes how to perform 2D SPECT forward and back-projection using the Julia package SPECTrecon.\n\nThis page comes from a single Julia file: 5-2d.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 5-2d.ipynb, or open it in binder here: 5-2d.ipynb.","category":"section"},{"location":"generated/examples/5-2d/#Setup","page":"SPECTrecon 2D use","title":"Setup","text":"Packages needed here.\n\nusing SPECTrecon: SPECTplan, psf_gauss\nusing SPECTrecon: project, project!, backproject, backproject!\nusing MIRTjim: jim, prompt\nusing ImagePhantoms: shepp_logan, SheppLoganEmis\nusing LinearAlgebra: mul!\nusing LinearMapsAA: LinearMapAA\nusing Plots: plot, default; default(markerstrokecolor=:auto)\n\nThe following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/5-2d/#Overview","page":"SPECTrecon 2D use","title":"Overview","text":"Real SPECT systems are inherently 3D imaging systems, but for the purpose of prototyping algorithms it can be useful to work with 2D simulations.\n\nCurrently, \"2D\" here means a 3D array with nz=1, i.e., a single slice. The key to working with a single slice is that the package allows the PSFs to have rectangular support px × pz where pz = 1, i.e., no blur along the axial (z) direction.","category":"section"},{"location":"generated/examples/5-2d/#Example","page":"SPECTrecon 2D use","title":"Example","text":"Start with a simple 2D digital phantom.\n\nT = Float32\nnx,ny,nz = 128,128,1\nxtrue = T.(shepp_logan(nx, SheppLoganEmis()))\nxtrue = reshape(xtrue, nx, ny, 1) # 3D array with nz=1\njim(xtrue, \"xtrue: SheppLoganEmis with size $(size(xtrue))\")","category":"section"},{"location":"generated/examples/5-2d/#PSF","page":"SPECTrecon 2D use","title":"PSF","text":"Create a synthetic depth-dependent PSF for a single view\n\npx,pz = 11,1 # pz=1 is crucial for 2D work\npsf1 = psf_gauss( ; ny, px, pz, fwhm_start = 1, fwhm_end = 4) # (px,pz,ny)\ntmp = reshape(psf1, px, ny) / maximum(psf1) # (px,ny)\nhx = (px-1)÷2\nplot(-hx:hx, tmp[:,[1:9:end-10;end]], markershape=:o, label=\"\",\n    title = \"Depth-dependent PSF profiles\",\n    xtick = [-hx, -2, 0, 2, hx], # (-1:1) .* ((px-1)÷2),\n    ytick = [0; round.(tmp[hx+1,end] * [0.5,1], digits=2); 0.5; 1],\n)\nprompt()\n\nIn general the PSF can vary from view to view due to non-circular detector orbits. For simplicity, here we illustrate the case where the PSF is the same for every view.\n\nnview = 80\npsfs = repeat(psf1, 1, 1, 1, nview)\nsize(psfs)","category":"section"},{"location":"generated/examples/5-2d/#Basic-SPECT-forward-projection","page":"SPECTrecon 2D use","title":"Basic SPECT forward projection","text":"Here is a simple illustration of a SPECT forward projection operation. (This is a memory inefficient way to do it!)\n\ndy = 4 # transaxial pixel size in mm\nmumap = zeros(T, size(xtrue)) # μ-map just zero for illustration here\nviews = project(xtrue, mumap, psfs, dy) # [nx,1,nview]\nsino = reshape(views, nx, nview)\nsize(sino)\n\nDisplay the calculated (i.e., simulated) projection views\n\njim(sino, \"Sinogram\")","category":"section"},{"location":"generated/examples/5-2d/#Basic-SPECT-back-projection","page":"SPECTrecon 2D use","title":"Basic SPECT back projection","text":"This illustrates an \"unfiltered backprojection\" that leads to a very blurry image (again, with a simple memory inefficient usage).\n\nFirst, back-project two \"rays\" to illustrate the depth-dependent PSF.\n\nsino1 = zeros(T, nx, nview)\nsino1[nx÷2, nview÷5] = 1\nsino1[nx÷2, 1] = 1\nsino1 = reshape(sino1, nx, nz, nview)\nback1 = backproject(sino1, mumap, psfs, dy)\njim(back1, \"Back-projection of two rays\")\n\nNow back-project all the views of the phantom.\n\nback = backproject(views, mumap, psfs, dy)\njim(back, \"Back-projection of ytrue\")","category":"section"},{"location":"generated/examples/5-2d/#Memory-efficiency","page":"SPECTrecon 2D use","title":"Memory efficiency","text":"For iterative reconstruction, one must do forward and back-projection repeatedly. It is more efficient to pre-allocate work arrays for those operations, instead of repeatedly making system calls.\n\nHere we illustrate the memory efficient versions that are recommended for iterative SPECT reconstruction.\n\nFirst construction the SPECT plan.\n\n#viewangle = (0:(nview-1)) * 2π # default\nplan = SPECTplan(mumap, psfs, dy; T)\n\nMutating version of forward projection:\n\ntmp = Array{T}(undef, nx, nz, nview)\nproject!(tmp, xtrue, plan)\n@assert tmp == views\n\nMutating version of back-projection:\n\ntmp = Array{T}(undef, nx, ny, nz)\nbackproject!(tmp, views, plan)\n@assert tmp ≈ back","category":"section"},{"location":"generated/examples/5-2d/#Using-LinearMapsAA","page":"SPECTrecon 2D use","title":"Using LinearMapsAA","text":"Calling project! and backproject! repeatedly leads to application-specific code. More general code uses the fact that SPECT projection and back-projection are linear operations, so we use LinearMapAA to define a \"system matrix\" for these operations.\n\nforw! = (y,x) -> project!(y, x, plan)\nback! = (x,y) -> backproject!(x, y, plan)\nidim = (nx,ny,nz)\nodim = (nx,nz,nview)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\n\nSimple forward and back-projection:\n\n@assert A * xtrue == views\n@assert A' * views ≈ back\n\nMutating version:\n\ntmp = Array{T}(undef, nx, nz, nview)\nmul!(tmp, A, xtrue)\n@assert tmp == views\ntmp = Array{T}(undef, nx, ny, nz)\nmul!(tmp, A', views)\n@assert tmp ≈ back","category":"section"},{"location":"generated/examples/5-2d/#Gram-matrix-impulse-response","page":"SPECTrecon 2D use","title":"Gram matrix impulse response","text":"points = zeros(T, nx, ny, nz)\npoints[nx÷2,ny÷2,1] = 1\npoints[3nx÷4,ny÷4,1] = 1\n\nimpulse = A' * (A * points)\njim(impulse, \"Impulse response of A'A\")\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/7-osem/#7-osem","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"This page illustrates Ordered-subset expectation-maximization (OS-EM) image reconstruction with the Julia package SPECTrecon.\n\nThis page comes from a single Julia file: 7-osem.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 7-osem.ipynb, or open it in binder here: 7-osem.ipynb.","category":"section"},{"location":"generated/examples/7-osem/#Setup","page":"SPECTrecon OS-EM","title":"Setup","text":"Packages needed here.\n\nusing SPECTrecon: psf_gauss, SPECTplan, project!, backproject!, Ablock\nusing SPECTrecon: osem, osem!, mlem!\nusing LinearMapsAA: LinearMapAA, LinearMapAO\nusing LinearAlgebra: mul!\nusing Distributions: Poisson\nusing MIRTjim: jim, prompt\nusing Plots: scatter, plot!, default; default(markerstrokecolor=:auto)\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/7-osem/#Overview","page":"SPECTrecon OS-EM","title":"Overview","text":"Ordered-subset expectation-maximization (OS-EM) is a commonly used algorithm for performing SPECT image reconstruction because of its favorable combination of image quality and speed. See Hudson and Larkin, 1994.","category":"section"},{"location":"generated/examples/7-osem/#Simulation-data","page":"SPECTrecon OS-EM","title":"Simulation data","text":"nx,ny,nz = 64,64,50\nT = Float32\nxtrue = zeros(T, nx,ny,nz) # simple phantom\nxtrue[(1nx÷4):(2nx÷3), 1ny÷5:(3ny÷5), 2nz÷6:(3nz÷6)] .= 1\nxtrue[(2nx÷5):(3nx÷5), 1ny÷5:(2ny÷5), 4nz÷6:(5nz÷6)] .= 2\n\naverage(x) = sum(x) / length(x)\nfunction mid3(x::AbstractArray{<:Number,3}) # 3 central planes\n    (nx,ny,nz) = size(x)\n    xy = x[:,:,ceil(Int, nz÷2)]\n    xz = x[:,ceil(Int,end/2),:]\n    zy = x[ceil(Int, nx÷2),:,:]'\n    return [xy xz; zy fill(average(xy), nz, nz)]\nend\njim(mid3(xtrue), \"Middle slices of xtrue\")","category":"section"},{"location":"generated/examples/7-osem/#PSF","page":"SPECTrecon OS-EM","title":"PSF","text":"Create a synthetic depth-dependent PSF for a single view\n\npx = 11\npsf1 = psf_gauss( ; ny, px)\njim(psf1, \"PSF for each of $ny planes\"; ratio=1)\n\nIn general the PSF can vary from view to view due to non-circular detector orbits. For simplicity, here we illustrate the case where the PSF is the same for every view.\n\nnview = 60\npsfs = repeat(psf1, 1, 1, 1, nview)\nsize(psfs)","category":"section"},{"location":"generated/examples/7-osem/#SPECT-system-model-using-LinearMapAA","page":"SPECTrecon OS-EM","title":"SPECT system model using LinearMapAA","text":"dy = 8 # transaxial pixel size in mm\nmumap = zeros(T, size(xtrue)) # zero μ-map just for illustration here\nplan = SPECTplan(mumap, psfs, dy; T)\n\nforw! = (y,x) -> project!(y, x, plan)\nback! = (x,y) -> backproject!(x, y, plan)\nidim = (nx,ny,nz)\nodim = (nx,nz,nview)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\n\nNoisy data\n\nif !@isdefined(ynoisy) # generate (scaled) Poisson data\n    ytrue = A * xtrue\n    target_mean = 20 # aim for mean of 20 counts per ray\n    scale = target_mean / average(ytrue)\n    scatter_fraction = 0.1 # 10% uniform scatter for illustration\n    scatter_mean = scatter_fraction * average(ytrue) # uniform for simplicity\n    background = scatter_mean * ones(T,nx,nz,nview)\n    ynoisy = rand.(Poisson.(scale * (ytrue + background))) / scale\nend\njim(ynoisy, \"$nview noisy projection views\")","category":"section"},{"location":"generated/examples/7-osem/#OS-EM-algorithm-basic-version","page":"SPECTrecon OS-EM","title":"OS-EM algorithm - basic version","text":"x0 = ones(T, nx, ny, nz) # initial uniform image\n\nniter = 8\nnblocks = 4\nAb = Ablock(plan, nblocks) # create a linear map for each block\n\nif !@isdefined(xhat1)\n    xhat1 = osem(x0, ynoisy, background, Ab; niter)\nend;\nnothing #hide\n\nThis preferable OS-EM version preallocates the output xhat2:\n\nif !@isdefined(xhat2)\n    xhat2 = copy(x0)\n    osem!(xhat2, x0, ynoisy, background, Ab; niter)\nend\n\n@assert xhat1 ≈ xhat2","category":"section"},{"location":"generated/examples/7-osem/#Compare-with-ML-EM","page":"SPECTrecon OS-EM","title":"Compare with ML-EM","text":"Run 30 iterations of ML-EM algorithm.\n\nniter_mlem = 30\nif !@isdefined(xhat3)\n    xhat3 = copy(x0)\n    mlem!(xhat3, x0, ynoisy, background, A; niter=niter_mlem)\nend\n\njim(jim(mid3(xhat2), \"OS-EM at $niter iterations\"),\n    jim(mid3(xhat3), \"ML-EM at $niter_mlem iterations\"))\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/2-rotate/#2-rotate","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"This page explains the image rotation portion of the Julia package SPECTrecon.jl.\n\nThis page comes from a single Julia file: 2-rotate.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 2-rotate.ipynb, or open it in binder here: 2-rotate.ipynb.","category":"section"},{"location":"generated/examples/2-rotate/#Setup","page":"SPECTrecon rotation","title":"Setup","text":"Packages needed here.\n\nusing SPECTrecon: plan_rotate, imrotate!, imrotate_adj!\nusing MIRTjim: jim, prompt\nusing Plots: scatter, scatter!, plot!, default\ndefault(markerstrokecolor=:auto, markersize=3)\n\nThe following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/2-rotate/#Overview","page":"SPECTrecon rotation","title":"Overview","text":"The first step in SPECT image forward projection is to rotate each slice of a 3D image volume to the appropriate view angle. In principle one could use any of numerous candidate interpolation methods for this task. However, because emission images are nonnegative and maximum likelihood methods for SPECT image reconstruction exploit that nonnegativity, it is desirable to use interpolators that preserve nonnegativity. This constraint rules out quadratic and higher B-splines, including the otherwise attractive cubic B-spline methods. On the other hand, nearest-neighbor interpolation (equivalent to 0th-order B-splines) does not provide adequate image quality. This leaves 1st-order interpolation methods as the most viable options.\n\nThis package supports two 1st-order linear interpolators:\n\n2D bilinear interpolation,\na 3-pass rotation method based on 1D linear interpolation.\n\nBecause image rotation is done repeatedly (for every slice of both the emission image and the attenuation map, for both projection and back-projection, and for multiple iterations), it is important for efficiency to use mutating methods rather than to repeatedly make heap allocations.\n\nFollowing other libraries like FFTW.jl, the rotation operations herein start with a plan where work arrays are preallocated for subsequent use. The plan is a Vector of PlanRotate objects: one for each thread. (Parallelism is across slices for a 3D image volume.) The number of threads defaults to Threads.nthreads().","category":"section"},{"location":"generated/examples/2-rotate/#Example","page":"SPECTrecon rotation","title":"Example","text":"Start with a 3D image volume (just 2 slices here for simplicity).\n\nT = Float32 # work with single precision to save memory\nimage = zeros(T, 64, 64, 2)\nimage[30:50,20:30,1] .= 1\nimage[25:28,20:40,2] .= 1\njim(image, \"Original image\")\n\nNow plan the rotation by specifying\n\nthe image size nx (it must be square, so ny=nx implicitly)\nthe Type used for the work arrays.\n\nplan2 = plan_rotate(size(image, 1); T)\n\nHere are the internals for the plan for the first thread:\n\nplan2[1]\n\nWith this plan preallocated, now we can rotate the image volume, specifying the rotation angle in radians:\n\nresult2 = similar(image) # allocate memory for the result\nimrotate!(result2, image, π/6, plan2) # mutates the first argument\njim(result2, \"Rotated image by π/6 (2D bilinear)\")\n\nThe default, shown above, uses 2D bilinear interpolation for rotation. That default is the recommended approach because it is faster.\n\nHere is the 3-pass 1D interpolation approach, included mainly for checking consistency with the historical ASPIRE approach used in Matlab version of MIRT.\n\nplan1 = plan_rotate(size(image, 1); T, method=:one)\n\nHere are the plan internals for the first thread:\n\nplan1[1]\n\nThe results of rotation using 3-pass 1D interpolation look quite similar:\n\nresult1 = similar(image)\nimrotate!(result1, image, π/6, plan1)\njim(result1, \"Rotated image by π/6 (3-pass 1D)\")\n\nHere are the difference images for comparison.\n\njim(result1 - result2, \"Difference images\")","category":"section"},{"location":"generated/examples/2-rotate/#Adjoint","page":"SPECTrecon rotation","title":"Adjoint","text":"To ensure adjoint consistency between SPECT forward- and back-projection, there is also an adjoint routine:\n\nadj2 = similar(result2)\nimrotate_adj!(adj2, result2, π/6, plan2)\njim(adj2, \"Adjoint image rotation (2D)\")\n\nadj1 = similar(result1)\nimrotate_adj!(adj1, result1, π/6, plan1)\njim(adj1, \"Adjoint image rotation (3-pass 1D)\")\n\nThe adjoint is not the same as the inverse so one does not expect the output here to match the original image!","category":"section"},{"location":"generated/examples/2-rotate/#LinearMap","page":"SPECTrecon rotation","title":"LinearMap","text":"One can form a linear map corresponding to image rotation using LinearMapAA. An operator like this may be useful as part of a motion-compensated image reconstruction method.\n\nusing LinearMapsAA: LinearMapAA\n\nnx = 20 # small size for illustration\nr1 = plan_rotate(nx; T, nthread = 1, method=:two)[1]\nr2 = plan_rotate(nx; T, nthread = 1, method=:one)[1]\nidim = (nx,nx)\nodim = (nx,nx)\nforw! = (y,x) -> imrotate!(y, x, π/6, r1)\nback! = (x,y) -> imrotate_adj!(x, y, π/6, r1)\nA1 = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\nforw! = (y,x) -> imrotate!(y, x, π/6, r2)\nback! = (x,y) -> imrotate_adj!(x, y, π/6, r2)\nA2 = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\n\nAfull1 = Matrix(A1)\nAadj1 = Matrix(A1')\nAfull2 = Matrix(A2)\nAadj2 = Matrix(A2')\njim(cat(dims=3, Afull1', Aadj1', Afull2', Aadj2'), \"Linear map for 2D rotation and its adjoint\")\n\nThe following verify adjoint consistency:\n\n@assert Afull1' ≈ Aadj1\n@assert Afull2' ≈ Aadj2\n\nApplying this linear map to a 2D or 3D image performs rotation:\n\nimage2 = zeros(nx,nx); image2[4:6, 5:13] .= 1\njim(cat(dims=3, image2, A2 * image2), \"Rotation via linear map: 2D\")\n\nHere is 3D too. The A2 * image3 here uses the advanced \"operator\" feature of LinearMapsAA.jl.\n\nimage3 = cat(dims=3, image2, image2')\njim(cat(dims=4, image3, A2 * image3), \"Rotation via linear map: 3D\")\n\nExamine row and column sums of linear map\n\nscatter(xlabel=\"pixel index\", ylabel=\"row or col sum\")\nscatter!(vec(sum(Afull1, dims=1)), label=\"dim1 sum1\", marker=:x)\nscatter!(vec(sum(Afull1, dims=2)), label=\"dim2 sum1\", marker=:square)\nscatter!(vec(sum(Afull2, dims=1)), label=\"dim1 sum2\")\nscatter!(vec(sum(Afull2, dims=2)), label=\"dim2 sum2\")\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/6-dl/#6-dl","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"This page describes how to end-to-end train unrolled deep learning algorithms using the Julia package SPECTrecon.\n\nThis page comes from a single Julia file: 6-dl.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 6-dl.ipynb, or open it in binder here: 6-dl.ipynb.","category":"section"},{"location":"generated/examples/6-dl/#Setup","page":"SPECTrecon deep learning use","title":"Setup","text":"Packages needed here.\n\nusing LinearAlgebra: norm, mul!\nusing SPECTrecon: SPECTplan, project!, backproject!, psf_gauss, mlem!\nusing MIRTjim: jim, prompt\nusing Plots: default; default(markerstrokecolor=:auto)\nusing ZygoteRules: @adjoint\nusing Flux: Chain, Conv, SamePad, relu, params, unsqueeze\nimport Flux # apparently needed for BSON @load\nimport NNlib\nusing LinearMapsAA: LinearMapAA\nusing Distributions: Poisson\nusing BSON: @load, @save\nimport BSON # load\nusing InteractiveUtils: versioninfo\nimport Downloads # download\n\nThe following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/6-dl/#Overview","page":"SPECTrecon deep learning use","title":"Overview","text":"Regularized expectation-maximization (reg-EM) is a commonly used algorithm for performing SPECT image reconstruction. This page considers regularizers of the form β2 * x - u^2, where u is an auxiliary variable that often refers to the image denoised by a CNN.","category":"section"},{"location":"generated/examples/6-dl/#Data-generation","page":"SPECTrecon deep learning use","title":"Data generation","text":"Simulated data used in this page are identical to SPECTrecon ML-EM. We repeat it again here for convenience.\n\nnx,ny,nz = 64,64,50\nT = Float32\nxtrue = zeros(T, nx,ny,nz)\nxtrue[(1nx÷4):(2nx÷3), 1ny÷5:(3ny÷5), 2nz÷6:(3nz÷6)] .= 1\nxtrue[(2nx÷5):(3nx÷5), 1ny÷5:(2ny÷5), 4nz÷6:(5nz÷6)] .= 2\n\naverage(x) = sum(x) / length(x)\nfunction mid3(x::AbstractArray{T,3}) where {T}\n    (nx,ny,nz) = size(x)\n    xy = x[:,:,ceil(Int, nz÷2)]\n    xz = x[:,ceil(Int,end/2),:]\n    zy = x[ceil(Int, nx÷2),:,:]'\n    return [xy xz; zy fill(average(xy), nz, nz)]\nend\njim(mid3(xtrue), \"Middle slices of xtrue\")","category":"section"},{"location":"generated/examples/6-dl/#PSF","page":"SPECTrecon deep learning use","title":"PSF","text":"Create a synthetic depth-dependent PSF for a single view\n\npx = 11\npsf1 = psf_gauss( ; ny, px)\njim(psf1, \"PSF for each of $ny planes\")\n\nIn general the PSF can vary from view to view due to non-circular detector orbits. For simplicity, here we illustrate the case where the PSF is the same for every view.\n\nnview = 60\npsfs = repeat(psf1, 1, 1, 1, nview)\nsize(psfs)","category":"section"},{"location":"generated/examples/6-dl/#SPECT-system-model-using-LinearMapAA","page":"SPECTrecon deep learning use","title":"SPECT system model using LinearMapAA","text":"dy = 8 # transaxial pixel size in mm\nmumap = zeros(T, size(xtrue)) # zero μ-map just for illustration here\nplan = SPECTplan(mumap, psfs, dy; T)\n\nforw! = (y,x) -> project!(y, x, plan)\nback! = (x,y) -> backproject!(x, y, plan)\nidim = (nx,ny,nz)\nodim = (nx,nz,nview)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\n\nGenerate noisy data\n\nif !@isdefined(ynoisy) # generate (scaled) Poisson data\n    ytrue = A * xtrue\n    target_mean = 20 # aim for mean of 20 counts per ray\n    scale = target_mean / average(ytrue)\n    scatter_fraction = 0.1 # 10% uniform scatter for illustration\n    scatter_mean = scatter_fraction * average(ytrue) # uniform for simplicity\n    background = scatter_mean * ones(T,nx,nz,nview)\n    ynoisy = rand.(Poisson.(scale * (ytrue + background))) / scale\nend\njim(ynoisy, \"$nview noisy projection views\"; ncol=10)","category":"section"},{"location":"generated/examples/6-dl/#ML-EM-algorithm","page":"SPECTrecon deep learning use","title":"ML-EM algorithm","text":"x0 = ones(T, nx, ny, nz) # initial uniform image\n\nniter = 30\n\nif !@isdefined(xhat1)\n    xhat1 = copy(x0)\n    mlem!(xhat1, x0, ynoisy, background, A; niter)\nend;\nnothing #hide\n\nDefine evaluation metric\n\nnrmse(x) = round(100 * norm(mid3(x) - mid3(xtrue)) / norm(mid3(xtrue)); digits=1)\nprompt()\n# jim(mid3(xhat1), \"MLEM NRMSE=$(nrmse(xhat1))%\") # display ML-EM reconstructed image","category":"section"},{"location":"generated/examples/6-dl/#Implement-a-3D-CNN-denoiser","page":"SPECTrecon deep learning use","title":"Implement a 3D CNN denoiser","text":"cnn = Chain(\n    Conv((3,3,3), 1 => 4, relu; stride = 1, pad = SamePad(), bias = true),\n    Conv((3,3,3), 4 => 4, relu; stride = 1, pad = SamePad(), bias = true),\n    Conv((3,3,3), 4 => 1; stride = 1, pad = SamePad(), bias = true),\n)\n\nShow how many parameters the CNN has\n\nparamCount = sum([sum(length, params(layer)) for layer in cnn])","category":"section"},{"location":"generated/examples/6-dl/#Custom-backpropagation","page":"SPECTrecon deep learning use","title":"Custom backpropagation","text":"Forward and back-projection are linear operations so their Jacobians are very simple and there is no need to auto-differentiate through the system matrix and that would be very computationally expensive. Instead, we tell Flux.jl to use the customized Jacobian when doing backpropagation.\n\nprojectb(x) = A * x\n@adjoint projectb(x) = A * x, dy -> (A' * dy, )\n\nbackprojectb(y) = A' * y\n@adjoint backprojectb(y) = A' * y, dx -> (A * dx, )","category":"section"},{"location":"generated/examples/6-dl/#Backpropagatable-regularized-EM-algorithm","page":"SPECTrecon deep learning use","title":"Backpropagatable regularized EM algorithm","text":"First define a function for unsqueezing the data because Flux CNN model expects a 5-dim tensor\n\nfunction unsqueeze45(x)\n    return unsqueeze(unsqueeze(x, 4), 5)\nend\n\n\"\"\"\n    bregem(projectb, backprojectb, y, r, Asum, x, cnn, β; niter = 1)\n\nBackpropagatable regularized EM reconstruction with CNN regularization\n-`projectb`: backpropagatable forward projection\n-`backprojectb`: backpropagatable backward projection\n-`y`: projections\n-`r`: scatters\n-`Asum`: A' * 1\n-`x`: current iterate\n-`cnn`: the CNN model\n-`β`: regularization parameter\n-`niter`: number of iteration for inner EM\n\"\"\"\nfunction bregem(\n    projectb::Function,\n    backprojectb::Function,\n    y::AbstractArray,\n    r::AbstractArray,\n    Asum::AbstractArray,\n    x::AbstractArray,\n    cnn::Union{Chain,Function},\n    β::Real;\n    niter::Int = 1,\n)\n\n    u = cnn(unsqueeze45(x))[:,:,:,1,1]\n    Asumu = Asum - β * u\n    Asumu2 = Asumu.^2\n    T = eltype(x)\n    for iter = 1:niter\n        eterm = backprojectb((y ./ (projectb(x) + r)))\n        eterm_beta = 4 * β * (x .* eterm)\n        x = max.(0, T(1/2β) * (-Asumu + sqrt.(Asumu2 + eterm_beta)))\n    end\n    return x\nend","category":"section"},{"location":"generated/examples/6-dl/#Loss-function","page":"SPECTrecon deep learning use","title":"Loss function","text":"We set β = 1 and train 2 outer iterations.\n\nβ = 1\nAsum = A' * ones(T, nx, nz, nview)\nfunction loss(xrecon, xtrue)\n    xiter1 = bregem(projectb, backprojectb, ynoisy, background,\n                    Asum, xrecon, cnn, β; niter = 1)\n    xiter2 = bregem(projectb, backprojectb, ynoisy, background,\n                    Asum, xiter1, cnn, β; niter = 1)\n    return sum(abs2, xiter2 - xtrue)\nend\n\nInitial loss\n\n@show loss(xhat1, xtrue)","category":"section"},{"location":"generated/examples/6-dl/#Train-the-CNN","page":"SPECTrecon deep learning use","title":"Train the CNN","text":"Uncomment the following code to train:\n\nusing Printf\nnepoch = 200\nfor e in 1:nepoch\n    @printf(\"epoch = %d, loss = %.2f\\n\", e, loss(xhat1, xtrue))\n    ps = Flux.params(cnn)\n    gs = gradient(ps) do\n        loss(xhat1, xtrue) # we start with the 30 iteration EM reconstruction\n    end\n    opt = ADAMW(0.002)\n    Flux.Optimise.update!(opt, ps, gs)\nend\n\nUncomment to save your trained model:\n\nfile = \"../data/trained-cnn-example-6-dl.bson\" # adjust path/name as needed\n@save file cnn\n\nLoad the pre-trained model (uncomment if you save your own model):\n\n@load file cnn\n\nThe code below here works fine when run via include from the REPL, but it fails with the error UndefVarError: NNlib not defined on the BSON.load step when run via Literate/Documenter. So for now it is just fenced off with isinteractive().\n\nif isinteractive()\n    url = \"https://github.com/JuliaImageRecon/SPECTrecon.jl/blob/main/data/trained-cnn-example-6-dl.bson?raw=true\"\n    tmp = tempname()\n    Downloads.download(url, tmp)\n    cnn = BSON.load(tmp)[:cnn]\nelse\n    cnn = x -> x # fake \"do-nothing CNN\" for Literate/Documenter version\nend\n\nPerform recon with pre-trained model.\n\nxiter1 = bregem(projectb, backprojectb, ynoisy, background,\n                Asum, xhat1, cnn, β; niter = 1)\nxiter2 = bregem(projectb, backprojectb, ynoisy, background,\n                Asum, xiter1, cnn, β; niter = 1)\n\nclim = (0,2)\njim(\n    jim(mid3(xtrue), \"xtrue\"; clim),\n    jim(mid3(xhat1), \"EM recon, NRMSE = $(nrmse(xhat1))%\"; clim),\n    jim(mid3(xiter1), \"Iter 1, NRMSE = $(nrmse(xiter1))%\"; clim),\n    jim(mid3(xiter2), \"Iter 2, NRMSE = $(nrmse(xiter2))%\"; clim),\n)\n\nFor the web-based Documenter/Literate version, the three NRMSE values will be the same because of the \"do-nothing\" CNN above. But if you download this file and run it locally, then you will see that the CNN reduces the NRMSE.\n\nA more thorough investigation would compare the CNN approach to a suitably optimized regularized approach; see https://doi.org/10.1109/EMBC46164.2021.9630985.","category":"section"},{"location":"generated/examples/6-dl/#Reproducibility","page":"SPECTrecon deep learning use","title":"Reproducibility","text":"This page was generated with the following version of Julia:\n\nusing InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')\n\nAnd with the following package versions\n\nimport Pkg; Pkg.status()\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"history/#History","page":"History","title":"History","text":"The SPECT forward and back-projection method implemented here is based on the 1992 paper by GL Zeng & GT Gullberg \"Frequency domain implementation of the three-dimensional geometric point response correction in SPECT imaging\" (DOI).\n\nHistorically there have been relatively few open-source libraries for SPECT image reconstruction, and to the best of our knowledge source code for the Zeng & Gullberg approach has not been available prior to this package.\n\nStarting in about 1995, the ASPIRE library, developed in the early 1990s at the University of Michigan, began providing precompiled binaries (from C99 source code) for 2D SPECT image reconstruction with documentation.\n\nIn about 1997, a 3D version of ASPIRE for SPECT reconstruction became available, again as precompiled binaries with documentation. Anastasia Yendiki was a key contributor to the SPECT code. As noted in a 2001 technical report we took pains to ensure that the forward and back-projector were (adjoint) consistent pairs. Around 2001 the work was extended to consider blob basis functions, leading to a 2004 comparison paper.\n\nSomewhere during that period the 3D SPECT projector / backprojector became available as precompiled MEX files for use with the Matlab version of the Michigan Image Reconstruction Toolbox.\n\nThe 3D version in ASPIRE precomputes rotated versions of the attenuation map, to save computation at the price of substantially more memory. That trade-off was reasonable in the era before machine learning. Today, with a focus on end-to-end training of image reconstruction methods in all modalities, including SPECT, it is desirable to have methods that use less memory to facilitate GPU implementations. This open-source Julia package is designed for the machine learning era. \n\nDevelopment work on this package is supported in part by the following projects led by Dr. Yuni Dewaraja:\n\nNIH Grant R01 EB022075\nNIH Grant R01 CA240706","category":"section"},{"location":"generated/examples/4-mlem/#4-mlem","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"This page illustrates ML-EM reconstruction with the Julia package SPECTrecon.\n\nThis page comes from a single Julia file: 4-mlem.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 4-mlem.ipynb, or open it in binder here: 4-mlem.ipynb.","category":"section"},{"location":"generated/examples/4-mlem/#Setup","page":"SPECTrecon ML-EM","title":"Setup","text":"Packages needed here.\n\nusing SPECTrecon: SPECTplan, psf_gauss, project!, backproject!, mlem, mlem!\nusing MIRTjim: jim, prompt\nusing Plots: scatter, plot!, default; default(markerstrokecolor=:auto)\n\nThe following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/4-mlem/#Overview","page":"SPECTrecon ML-EM","title":"Overview","text":"Maximum-likelihood expectation-maximization (ML-EM) is a classic algorithm for performing SPECT image reconstruction.","category":"section"},{"location":"generated/examples/4-mlem/#Simulation-data","page":"SPECTrecon ML-EM","title":"Simulation data","text":"nx,ny,nz = 64,64,50\nT = Float32\nxtrue = zeros(T, nx,ny,nz)\nxtrue[(1nx÷4):(2nx÷3), 1ny÷5:(3ny÷5), 2nz÷6:(3nz÷6)] .= 1\nxtrue[(2nx÷5):(3nx÷5), 1ny÷5:(2ny÷5), 4nz÷6:(5nz÷6)] .= 2\n\naverage(x) = sum(x) / length(x)\nfunction mid3(x::AbstractArray{T,3}) where {T}\n    (nx,ny,nz) = size(x)\n    xy = x[:,:,ceil(Int, nz÷2)]\n    xz = x[:,ceil(Int,end/2),:]\n    zy = x[ceil(Int, nx÷2),:,:]'\n    return [xy xz; zy fill(average(xy), nz, nz)]\nend\njim(mid3(xtrue), \"Middle slices of xtrue\")","category":"section"},{"location":"generated/examples/4-mlem/#PSF","page":"SPECTrecon ML-EM","title":"PSF","text":"Create a synthetic depth-dependent PSF for a single view\n\npx = 11\npsf1 = psf_gauss( ; ny, px)\njim(psf1, \"PSF for each of $ny planes\")\n\nIn general the PSF can vary from view to view due to non-circular detector orbits. For simplicity, here we illustrate the case where the PSF is the same for every view.\n\nnview = 60\npsfs = repeat(psf1, 1, 1, 1, nview)\nsize(psfs)","category":"section"},{"location":"generated/examples/4-mlem/#SPECT-system-model-using-LinearMapAA","page":"SPECTrecon ML-EM","title":"SPECT system model using LinearMapAA","text":"dy = 8 # transaxial pixel size in mm\nmumap = zeros(T, size(xtrue)) # zero μ-map just for illustration here\nplan = SPECTplan(mumap, psfs, dy; T)\n\nusing LinearMapsAA: LinearMapAA\nusing LinearAlgebra: mul!\nforw! = (y,x) -> project!(y, x, plan)\nback! = (x,y) -> backproject!(x, y, plan)\nidim = (nx,ny,nz)\nodim = (nx,nz,nview)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)","category":"section"},{"location":"generated/examples/4-mlem/#Basic-Expectation-Maximization-(EM)-algorithm","page":"SPECTrecon ML-EM","title":"Basic Expectation-Maximization (EM) algorithm","text":"Noisy data\n\nusing Distributions: Poisson\n\nif !@isdefined(ynoisy) # generate (scaled) Poisson data\n    ytrue = A * xtrue\n    target_mean = 20 # aim for mean of 20 counts per ray\n    scale = target_mean / average(ytrue)\n    scatter_fraction = 0.1 # 10% uniform scatter for illustration\n    scatter_mean = scatter_fraction * average(ytrue) # uniform for simplicity\n    background = scatter_mean * ones(T,nx,nz,nview)\n    ynoisy = rand.(Poisson.(scale * (ytrue + background))) / scale\nend\njim(ynoisy, \"$nview noisy projection views\")","category":"section"},{"location":"generated/examples/4-mlem/#ML-EM-algorithm-basic-version","page":"SPECTrecon ML-EM","title":"ML-EM algorithm - basic version","text":"x0 = ones(T, nx, ny, nz) # initial uniform image\n\nniter = 30\nif !@isdefined(xhat1)\n    xhat1 = mlem(x0, ynoisy, background, A; niter)\nend\nsize(xhat1)\n\nThis preferable ML-EM version preallocates the output xhat2:\n\nif !@isdefined(xhat2)\n    xhat2 = copy(x0)\n    mlem!(xhat2, x0, ynoisy, background, A; niter)\nend\n@assert xhat1 ≈ xhat2\n\njim(mid3(xhat2), \"ML-EM at $niter iterations\")\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"methods/#Methods-list","page":"Methods","title":"Methods list","text":"","category":"section"},{"location":"methods/#Methods-usage","page":"Methods","title":"Methods usage","text":"","category":"section"},{"location":"methods/#SPECTrecon.SPECTrecon","page":"Methods","title":"SPECTrecon.SPECTrecon","text":"SPECTrecon\n\nSystem matrix (forward and back-projector) for SPECT image reconstruction.\n\n\n\n\n\n","category":"module"},{"location":"methods/#SPECTrecon.Rotate1D","page":"Methods","title":"SPECTrecon.Rotate1D","text":"Rotate1D = RotateMode{:one}()\n\nRotate using 3-pass 1D interpolation\n\n\n\n\n\n","category":"constant"},{"location":"methods/#SPECTrecon.Rotate2D","page":"Methods","title":"SPECTrecon.Rotate2D","text":"Rotate2D = RotateMode{:two}()\n\nRotate using 1-pass 2D bilinear interpolation\n\n\n\n\n\n","category":"constant"},{"location":"methods/#SPECTrecon.PlanPSF","page":"Methods","title":"SPECTrecon.PlanPSF","text":"PlanPSF{T,Tf,Ti}( ; nx::Int, nz::Int, px::Int, pz::Int, T::Type)\n\nStruct for storing work arrays and factors for 2D convolution for one thread. Each PSF is px × pz\n\nT datatype of work arrays (subtype of AbstractFloat)\nnx::Int = 128 (ny implicitly the same)\nnz::Int = nx image size is [nx,nx,nz]\npx::Int = 1\npz::Int = px (PSF size)\npadsize::Tuple : (padup, paddown, padleft, padright)\nworkmat [nx+padup+paddown, nz+padleft+padright] 2D padded image for FFT convolution\nworkvecx [nx+padup+paddown,]: 1D work vector\nworkvecz [nz+padleft+padright,]: 1D work vector\nimg_compl [nx+padup+paddown, nz+padleft+padright]: 2D [complex] padded image for FFT\nker_compl [nx+padup+paddown, nz+padleft+padright]: 2D [complex] padded image for FFT\nfft_plan::Tf plan for doing FFT; see plan_fft!\nifft_plan::Ti plan for doing IFFT; see plan_ifft!\n\n\n\n\n\n","category":"type"},{"location":"methods/#SPECTrecon.PlanRotate","page":"Methods","title":"SPECTrecon.PlanRotate","text":"PlanRotate{T, R}\n\nStruct for storing work arrays and factors for 2D square image rotation for one thread\n\nT datatype of work arrays (default Float32)\nR::RotateMode\nnx::Int image size\npadsize::Int : pad each side of image by this much\nworkmat1 [nx + 2 * padsize, nx + 2 * padsize] padded work matrix\nworkmat2 [nx + 2 * padsize, nx + 2 * padsize] padded work matrix\ninterp::SparseInterpolator{T, 2, 1}\n\n\n\n\n\n","category":"type"},{"location":"methods/#SPECTrecon.RotateMode","page":"Methods","title":"SPECTrecon.RotateMode","text":"RotateMode\n\nType to control image rotation method.\n\nRotate1D : 3-pass 1D interpolation\nRotate2D : 1-pass 2D bilinear interpolation\n\n\n\n\n\n","category":"type"},{"location":"methods/#SPECTrecon.SPECTplan","page":"Methods","title":"SPECTrecon.SPECTplan","text":"SPECTplan\n\nStruct for storing key factors for a SPECT system model\n\nT datatype of work arrays\nimgsize size of image\npx,pz psf dimension\nimgr [nx, ny, nz] 3D rotated version of image\nadd_img [nx, ny, nz] 3D image for adding views and backprojection\nmumap [nx,ny,nz] attenuation map, must be 3D, possibly zeros()\nmumapr [nx, ny, nz] 3D rotated mumap\nexp_mumapr [nx, nz] 2D exponential rotated mumap\npsfs [px,pz,ny,nview] point spread function, must be 4D, with px andpz` odd, and symmetric for each slice\nnview number of views, must be integer\nviewangle set of view angles, must be from 0 to 2π\ninterpmeth interpolation method: :one means 1d; :two means 2d\nmode pre-allocation method: :fast means faster; :mem means use less memory\ndy voxel size in y direction (dx is the same value)\nnthread number of CPU threads used to process data; must be integer\nplanrot Vector of struct PlanRotate\nplanpsf Vector of struct PlanPSF\n\nCurrently code assumes the following:\n\neach of the nview projection views is [nx,nz]\nnx = ny\nuniform angular sampling\npsf is symmetric\nmultiprocessing using # of threads specified by Threads.nthreads()\n\nConstructor is not type stable due to the Union, but this is OK because construction is done just once before iterating.\n\n\n\n\n\n","category":"type"},{"location":"methods/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Vector{<:PlanPSF}}","page":"Methods","title":"Base.show","text":"show(io::IO, mime::MIME\"text/plain\", vp::Vector{<:PlanPSF})\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Union{Tuple{R}, Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, Array{PlanRotate{T, R}, 1}}} where {T, R}","page":"Methods","title":"Base.show","text":"show(io::IO, mime::MIME\"text/plain\", vp::Vector{<:PlanRotate})\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Union{Tuple{R}, Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, PlanRotate{T, R}}} where {T, R}","page":"Methods","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", plan::PlanRotate)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Union{Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, PlanPSF{T}}} where T","page":"Methods","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", plan::PlanPSF)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Union{Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, SPECTplan{T}}} where T","page":"Methods","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", plan::SPECTplan)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.sizeof-Tuple{T} where T<:PlanPSF","page":"Methods","title":"Base.sizeof","text":"sizeof(::PlanPSF)\n\nShow size in bytes of PlanPSF object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.sizeof-Tuple{T} where T<:SPECTplan","page":"Methods","title":"Base.sizeof","text":"sizeof(::SPECTplan)\n\nShow size in bytes of SPECTplan object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.sizeof-Tuple{T} where T<:Union{PlanRotate, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"Base.sizeof","text":"sizeof(::PlanRotate)\n\nShow size in bytes of PlanRotate object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.Ablock-Tuple{SPECTplan, Int64}","page":"Methods","title":"SPECTrecon.Ablock","text":"Ablock(plan, nblocks)\n\nGenerate a vector of linear maps for OSEM. -plan: SPECTrecon plan -nblocks: Number of blocks in OSEM\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject!-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, SPECTplan}","page":"Methods","title":"SPECTrecon.backproject!","text":"backproject!(image, views, plan ; index)\n\nBackproject multiple views into image. Array image is not initialized to zero; caller must do that.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject!-Tuple{AbstractArray{<:Number, 3}, AbstractMatrix{<:Number}, SPECTplan, Int64, Int64}","page":"Methods","title":"SPECTrecon.backproject!","text":"backproject!(image, view, plan, buffer_id, viewidx)\n\nBackproject a single view.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject!-Tuple{AbstractArray{<:Number, 3}, AbstractMatrix{<:Number}, SPECTplan, Int64}","page":"Methods","title":"SPECTrecon.backproject!","text":"backproject!(image, view, plan, viewidx)\n\nBackproject a single view.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, AbstractArray{<:Number, 4}, Number}","page":"Methods","title":"SPECTrecon.backproject","text":"image = backproject(views, mumap, psfs, dy; interpmeth, kwargs...)\n\nSPECT backproject views using attenuation map mumap and PSF array psfs for pixel size dy. This method initializes the plan as a convenience. Most users should use backproject! instead after initializing those, for better efficiency.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject-Tuple{AbstractArray{<:Number, 3}, SPECTplan}","page":"Methods","title":"SPECTrecon.backproject","text":"image = backproject(views, plan ; kwargs...)\n\nSPECT backproject views; this allocates the returned 3D array.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.copy3dj!-Tuple{AbstractMatrix, AbstractArray{<:Any, 3}, Int64}","page":"Methods","title":"SPECTrecon.copy3dj!","text":"copy3dj!(mat2d, mat3d, j)\n\nNon-allocating mat2d .= mat3d[:,j,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv!-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, Vector{<:PlanPSF}}","page":"Methods","title":"SPECTrecon.fft_conv!","text":"fft_conv!(output, image3, ker3, plans)\n\nMutating version of convolving a 3D image3 with a set of 2D symmetric kernels stored in 3D array ker3 using foreach.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, PlanPSF}","page":"Methods","title":"SPECTrecon.fft_conv!","text":"fft_conv!(output, img, ker, plan)\n\nConvolve 2D image img with 2D (symmetric!) kernel ker using FFT, storing the result in output.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv-Union{Tuple{K}, Tuple{I}, Tuple{AbstractMatrix{I}, AbstractMatrix{K}}} where {I<:Number, K<:Number}","page":"Methods","title":"SPECTrecon.fft_conv","text":"fft_conv(img, ker; T)\n\nConvolve 2D image img with 2D (symmetric!) kernel ker using FFT.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv_adj!-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, Vector{<:PlanPSF}}","page":"Methods","title":"SPECTrecon.fft_conv_adj!","text":"fft_conv_adj!(output, image3, ker3, plans)\n\nAdjoint of fft_conv.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv_adj!-Union{Tuple{T}, Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, PlanPSF{T}}} where T","page":"Methods","title":"SPECTrecon.fft_conv_adj!","text":"fft_conv_adj!(output, img, ker, plan)\n\nAdjoint of fft_conv!.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv_adj-Union{Tuple{K}, Tuple{I}, Tuple{AbstractMatrix{I}, AbstractMatrix{K}}} where {I<:Number, K<:Number}","page":"Methods","title":"SPECTrecon.fft_conv_adj","text":"fft_conv_adj(img, ker; T)\n\nAdjoint of fft_conv.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv_adj2!-Tuple{AbstractArray{<:Number, 3}, AbstractMatrix{<:Number}, AbstractArray{<:Number, 3}, Vector{<:PlanPSF}}","page":"Methods","title":"SPECTrecon.fft_conv_adj2!","text":"fft_conv_adj2!(output, image2, ker3, plans)\n\nMutating version of adjoint of convolving a 2D image2 with each 2D kernel in the 3D array ker3.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fftshift2!-Tuple{AbstractMatrix, AbstractMatrix}","page":"Methods","title":"SPECTrecon.fftshift2!","text":"fftshift2!(dst, src)\n\nSame as fftshift in 2d, but non-allocating\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imfilterz!-Tuple{PlanPSF}","page":"Methods","title":"SPECTrecon.imfilterz!","text":"imfilterz!(plan)\n\nFFT-based convolution of plan.img_compl and kernel plan.ker_compl (not centered), storing result in plan.workmat. Over-writes plan.ker_compl.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate!","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, image3, θ, plans, ntasks=nthreads)\n\nIn-place version of rotating a 3D image3 by θ in counter-clockwise direction (opposite to imrotate in Julia) using foreach with ntasks.\n\n\n\n\n\n","category":"function"},{"location":"methods/#SPECTrecon.imrotate!-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, Number, Vector{<:PlanRotate}, Symbol}","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, image3, θ, plans, :thread)\n\nMutating version of rotating a 3D image3 by θ in counter-clockwise direction (opposite of imrotate in Julia) writing result into output, using Threads.@threads.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, PlanRotate{<:Number, RotateMode{:one}}}","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, img, θ, plan)\n\nRotate a 2D image img by angle θ ∈ [0,2π] in counter-clockwise direction (opposite to imrotate in Julia) using 3-pass 1d linear interpolations.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate!-Union{Tuple{T}, Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, PlanRotate{T, RotateMode{:two}}}} where T","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, img, θ, plan)\n\nRotate a 2D image img by angle θ ∈ [0,2π] in counter-clockwise direction (opposite to imrotate in Julia) using 2d bilinear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate-Union{Tuple{I}, Tuple{AbstractMatrix{I}, Number}} where I<:Number","page":"Methods","title":"SPECTrecon.imrotate","text":"imrotate(img, θ; method::Symbol=:two)\n\nRotate a 2D image img by angle θ ∈ [0,2π] in counter-clockwise direction (opposite to imrotate in Julia) using either 2d linear interpolation (for :two) or 3-pass 1D interpolation (for :one)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj!","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, image3, θ, plans, ntasks=nthreads)\n\nAdjoint of imrotate! using foreach.\n\n\n\n\n\n","category":"function"},{"location":"methods/#SPECTrecon.imrotate_adj!-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, Number, Vector{<:PlanRotate}, Symbol}","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, image3, θ, plans, :thread)\n\nAdjoint of imrotate! using @threads.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, PlanRotate{<:Number, RotateMode{:one}}}","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, img, θ, plan)\n\nAdjoint of imrotate! for a 2D image using 3-pass 1d linear interpolations.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj!-Union{Tuple{T}, Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, PlanRotate{T, RotateMode{:two}}}} where T","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, img, θ, plan)\n\nAdjoint of imrotate! for a 2D image using 2D bilinear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj-Union{Tuple{I}, Tuple{AbstractMatrix{I}, Number}} where I<:Number","page":"Methods","title":"SPECTrecon.imrotate_adj","text":"imrotate_adj(img, θ; method::Symbol=:two)\n\nAdjoint of rotating a 2D image img by angle θ ∈ [0,2π] in counter-clockwise direction (opposite to imrotate in Julia) using either 2d linear interpolations or 3-pass 1D interpolation.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.linearinterp!-Tuple{LinearInterpolators.SparseInterpolators.SparseInterpolator, Number, Number, Int64}","page":"Methods","title":"SPECTrecon.linearinterp!","text":"linearinterp!(A, s, e, len)\n\nAssign key values in SparseInterpolator (linear) A that are calculated from s, e and len. s means start (x[1]) e means end (x[end]) len means length (length(x))\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.mlem!-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Union{AbstractArray, LinearMapsAA.LinearMapAO}}","page":"Methods","title":"SPECTrecon.mlem!","text":"mlem!(out, x0, ynoisy, background, A; niter = 20)\n\nInplace version of ML-EM algorithm for emission tomography image reconstruction.\n\nout: Output\nx0: Initial guess\nynoisy: (Noisy) measurements\nbackground: Background effects, e.g., scatters\nA: System matrix\nniter: Number of iterations\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.mlem-Tuple{AbstractArray, Vararg{Any}}","page":"Methods","title":"SPECTrecon.mlem","text":"mlem(x0, ynoisy, background, A; niter = 20)\n\nML-EM algorithm for emission tomography image reconstruction.\n\nx0: Initial guess\nynoisy: (Noisy) measurements\nbackground: Background effects, e.g., scatters\nA: System matrix\nniter: Number of iterations\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.mul3dj!-Tuple{AbstractArray{<:Any, 3}, AbstractMatrix, Int64}","page":"Methods","title":"SPECTrecon.mul3dj!","text":"mul3dj!(mat3d, mat2d, j)\n\nNon-allocating mat3d[:,j,:] *= mat2d\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.osem!-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Union{Vector{AbstractArray}, Vector{LinearMapsAA.LinearMapAO}}}","page":"Methods","title":"SPECTrecon.osem!","text":"osem!(out, x0, ynoisy, background, Ab; niter = 20)\n\nOS-EM algorithm for SPECT reconstruction.\n\nout: Output\nx0: Initial estimate\nynoisy: (Noisy) measurements\nbackground: Background effects, e.g., scatters\nAb: Vector of system matrix\nniter: Number of iterations\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.osem-Tuple{AbstractArray, Vararg{Any}}","page":"Methods","title":"SPECTrecon.osem","text":"osem(x0, ynoisy, background, Ab; niter = 20)\n\nOS-EM algorithm for SPECT reconstruction.\n\nx0: Initial guess\nynoisy: (Noisy) measurements\nbackground: Background effects, e.g., scatters\nAb: Vector of system matrix\nniter: Number of iterations\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.pad2sizezero!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix, Tuple{Int64, Int64}}} where T","page":"Methods","title":"SPECTrecon.pad2sizezero!","text":"pad2sizezero!(output, img, padsize)\n\nNon-allocating version of padding: `output[paddims[1]+1 : paddims[1]+dims[1],         paddims[2]+1 : paddims[2]+dims[2]]) .= img\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.pad_it!-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{T, D}, NTuple{D, Int64}}} where {D, T<:Number}","page":"Methods","title":"SPECTrecon.pad_it!","text":"pad_it!(X, padsize)\n\nZero-pad X to padsize\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.padrepl!-Tuple{AbstractMatrix, AbstractMatrix, NTuple{4, Int64}}","page":"Methods","title":"SPECTrecon.padrepl!","text":"padrepl!(output, img, padsize)\n\nPad with replication from img into output\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.padzero!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix, NTuple{4, Int64}}} where T","page":"Methods","title":"SPECTrecon.padzero!","text":"padzero!(output, img, pad_x, pad_y)\n\nMutating version of padding a 2D image by filling zeros. Output has size (size(img, 1) + padsize[1] + padsize[2], size(img, 2) + padsize[3] + padsize[4]).\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plan_psf-Tuple{}","page":"Methods","title":"SPECTrecon.plan_psf","text":"plan_psf( ; nx::Int, nz::Int, px::Int, pz::Int, nthread::Int, T::Type)\n\nMake Vector of structs for storing work arrays and factors for 2D convolution with SPECT depth-dependent PSF model, threaded across planes parallel to detector. Option\n\nnx::Int = 128\nnz::Int = nx\npx::Int = 1\npz::Int = px PSF size is px × pz\nT : datatype of work arrays, defaults to Float32\nnthread::Int # of threads, defaults to Threads.nthreads()\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plan_rotate-Tuple{Int64}","page":"Methods","title":"SPECTrecon.plan_rotate","text":"plan_rotate(nx::Int; T::Type{<:AbstractFloat}, method::Symbol)\n\nMake Vector of PlanRotate structs for storing work arrays and factors for threaded rotation of a stack of 2D square images.\n\nInput\n\nnx::Int must equal to ny (square images only)\n\nOption\n\nT : datatype of work arrays, defaults to Float32\nmethod::Symbol : default is :two for 2D interpolation; use :one for 3-pass rotation with 1D interpolation\nnthread::Int : default to Threads.nthreads() The other useful option is 1 when rotating just one image.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus1di!-Tuple{AbstractMatrix, AbstractVector, Int64}","page":"Methods","title":"SPECTrecon.plus1di!","text":"plus1di!(mat2d, mat1d)\n\nNon-allocating mat2d[i, :] += mat1d\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus1dj!-Tuple{AbstractMatrix, AbstractVector, Int64}","page":"Methods","title":"SPECTrecon.plus1dj!","text":"plus1dj!(mat2d, mat1d)\n\nNon-allocating mat2d[:, j] += mat1d\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus2di!-Tuple{AbstractVector, AbstractMatrix, Int64}","page":"Methods","title":"SPECTrecon.plus2di!","text":"plus2di!(mat1d, mat2d, i)\n\nNon-allocating mat1d += mat2d[i,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus2dj!-Tuple{AbstractVector, AbstractMatrix, Int64}","page":"Methods","title":"SPECTrecon.plus2dj!","text":"plus2dj!(mat1d, mat2d, j)\n\nNon-allocating mat1d += mat2d[:,j]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus3di!-Tuple{AbstractMatrix, AbstractArray{<:Any, 3}, Int64}","page":"Methods","title":"SPECTrecon.plus3di!","text":"plus3di!(mat2d, mat3d, i)\n\nNon-allocating mat2d += mat3d[i,:,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus3dj!-Tuple{AbstractMatrix, AbstractArray{<:Any, 3}, Int64}","page":"Methods","title":"SPECTrecon.plus3dj!","text":"plus3dj!(mat2d, mat3d, j)\n\nNon-allocating mat2d += mat3d[:,j,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus3dk!-Tuple{AbstractMatrix, AbstractArray{<:Any, 3}, Int64}","page":"Methods","title":"SPECTrecon.plus3dk!","text":"plus3dk!(mat2d, mat3d, k)\n\nNon-allocating mat2d += mat3d[:,:,k]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project!-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, SPECTplan}","page":"Methods","title":"SPECTrecon.project!","text":"project!(views, image, plan; index)\n\nProject image into multiple views with indexes index (defaults to 1:nview). The 3D views array must be pre-allocated, but need not be initialized.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project!-Tuple{AbstractMatrix{<:Number}, AbstractArray{<:Number, 3}, SPECTplan, Int64, Int64}","page":"Methods","title":"SPECTrecon.project!","text":"project!(view, plan, image, buffer_id, viewidx)\n\nSPECT projection of image into a single view with index viewidx. The view must be pre-allocated but need not be initialized to zero.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project!-Tuple{AbstractMatrix{<:Number}, AbstractArray{<:Number, 3}, SPECTplan, Int64}","page":"Methods","title":"SPECTrecon.project!","text":"project!(view, plan, image, viewidx)\n\nSPECT projection of image into a single view with index viewidx. The view must be pre-allocated but need not be initialized to zero.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, AbstractArray{<:Number, 4}, Number}","page":"Methods","title":"SPECTrecon.project","text":"views = project(image, mumap, psfs, dy; interpmeth, kwargs...)\n\nConvenience method for SPECT forward projector that does all allocation including initializing plan.\n\nIn\n\nimage : 3D array (nx,ny,nz)\nmumap : (nx,ny,nz) 3D attenuation map, possibly zeros()\npsfs : 4D PSF array\ndy::RealU : pixel size\n\nOption\n\ninterpmeth : :one or :two\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project-Tuple{AbstractArray{<:Number, 3}, SPECTplan}","page":"Methods","title":"SPECTrecon.project","text":"views = project(image, plan ; kwargs...)\n\nConvenience method for SPECT forward projector that allocates and returns views.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.psf_gauss-Tuple{}","page":"Methods","title":"SPECTrecon.psf_gauss","text":"psf_gauss( ; ny, px, pz, fwhm_start, fwhm_end, fwhm, fwhm_x, fwhm_z, T)\n\nCreate depth-dependent Gaussian PSFs having specified full-width half-maximum (FHWM) values.\n\nOptions\n\n'ny::Int = 128'\n'px::Int = 11' (should be odd)\n'pz::Int = px' (should be odd)\n'fwhm_start::Real = 1'\n'fwhm_end::Real = 4'\n'fwhm::AbstractVector{<:Real} = range(fwhmstart, fwhmend, ny)'\n'fwhm_x::AbstractVector{<:Real} = fwhm,\n'fwhmz::AbstractVector{<:Real} = fwhmx'\n'T::Type == Float32'\n\nReturned psf is [px, pz, ny] where each PSF sums to 1.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rot180!-Tuple{AbstractMatrix, AbstractMatrix}","page":"Methods","title":"SPECTrecon.rot180!","text":"rot180!(B::AbstractMatrix, A::AbstractMatrix)\n\nIn place version of rot180, returning rotation of A in B.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rot_f90!-Tuple{AbstractMatrix, AbstractMatrix, Int64}","page":"Methods","title":"SPECTrecon.rot_f90!","text":"rot_f90!(output, img, m)\n\nIn-place version of rotating an image by 90/180/270 degrees\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rot_f90_adj!-Tuple{AbstractMatrix, AbstractMatrix, Int64}","page":"Methods","title":"SPECTrecon.rot_f90_adj!","text":"rot_f90_adj!(output, img, m)\nThe adjoint of rotating an image by 90/180/270 degrees\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_x!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_x!","text":"rotate_x!(output, img, tan_θ, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_x_adj!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_x_adj!","text":"rotate_x_adj!(output, img, tan_θ, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_y!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_y!","text":"rotate_y!(output, img, sin_θ, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_y_adj!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_y_adj!","text":"rotate_y_adj!(output, img, sin_θ, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotl90!-Tuple{AbstractMatrix, AbstractMatrix}","page":"Methods","title":"SPECTrecon.rotl90!","text":"rotl90!(B::AbstractMatrix, A::AbstractMatrix)\n\nIn place version of rotl90, returning rotation of A in B.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotr90!-Tuple{AbstractMatrix, AbstractMatrix}","page":"Methods","title":"SPECTrecon.rotr90!","text":"rotr90!(B::AbstractMatrix, A::AbstractMatrix)\n\nIn place version of rotr90, returning rotation of A in B.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.scale3dj!-Tuple{AbstractMatrix, AbstractArray{<:Any, 3}, Int64, Number}","page":"Methods","title":"SPECTrecon.scale3dj!","text":"scale3dj!(mat2d, mat3d, j, s)\n\nNon-allocating mat2d = s * mat3d[:,j,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.spawner-Tuple{Any, Int64, Int64}","page":"Methods","title":"SPECTrecon.spawner","text":"spawner(fun!, nthread::Int, ntask::Int)\n\nApply fun!(buffer_id, task) for task in 1:ntask where buffer_id is in {1, …, nthread}\n\nA single-thread version of this would simply be fun!.(1, 1:ntask)\n\n\n\n\n\n","category":"method"},{"location":"#Documentation-for-[SPECTrecon](https://github.com/JuliaImageRecon/SPECTrecon.jl)","page":"Home","title":"Documentation for SPECTrecon","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"This Julia module provides SPECT forward and back projectors for parallel-beam collimators, accounting for attenuation and depth-dependent collimator response. (Compton scatter within the object is not modeled.)\n\nDesigned for use with the Michigan Image Reconstruction Toolbox (MIRT) and similar frameworks.\n\nThe method implemented here is based on the 1992 paper by GL Zeng & GT Gullberg \"Frequency domain implementation of the three-dimensional geometric point response correction in SPECT imaging\" (IEEE Tr. on Nuclear Science, 39(5-1):1444-53, Oct 1992) (DOI).\n\nThe forward projection method works as follows.\n\nThe emission image and the attenuation map are rotated (slice by slice) to the desired view angle using either 2D bilinear interpolation or a 3-pass rotation method based on linear interpolation.\nEach (rotated) plane is convolved with the given point spread function (PSF) of the collimator and summed, accounting for attenuation using the \"central ray\" approximation.\n\nThe back-projection method is the exact adjoint of the forward projector.\n\nSee the \"Examples\" for details.","category":"section"},{"location":"generated/examples/1-overview/#1-overview","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"This page gives an overview of the Julia package SPECTrecon.\n\nThis page comes from a single Julia file: 1-overview.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 1-overview.ipynb, or open it in binder here: 1-overview.ipynb.","category":"section"},{"location":"generated/examples/1-overview/#Setup","page":"SPECTrecon overview","title":"Setup","text":"Packages needed here.\n\nusing SPECTrecon: plan_psf, psf_gauss, SPECTplan\nusing SPECTrecon: project, project!, backproject, backproject!\nusing MIRTjim: jim, prompt\nusing LinearAlgebra: mul!\nusing LinearMapsAA: LinearMapAA\nusing Plots: scatter, plot!, default; default(markerstrokecolor=:auto)\nusing Plots # @animate, gif\nusing InteractiveUtils: versioninfo\n\nThe following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/1-overview/#Overview","page":"SPECTrecon overview","title":"Overview","text":"To perform SPECT image reconstruction, one must have a model for the imaging system encapsulated in a forward projector and back projector.\n\nMathematically, we write the forward projection process in SPECT as \"y = A * x\" where A is a \"system matrix\" that models the physics of the imaging system (including depth-dependent collimator/detector response and attenuation) and \"x\" is the current guess of the emission image.\n\nHowever, in code we usually cannot literally store \"A\" as dense matrix because it is too large. A typical size in SPECT is that the image x is nx × ny × nz = 128 × 128 × 100 and the array of projection views y is nx × nz × nview = 128 × 100 × 120. So the system matrix A has 1536000 × 1638400 elements which is far to many to store, even accounting for some sparsity.\n\nInstead, we write functions called forward projectors that calculate A * x \"on the fly\".\n\nSimilarly, the operation A' * y is called \"back projection\", where A' denotes the transpose or \"adjoint\" of A.","category":"section"},{"location":"generated/examples/1-overview/#Example","page":"SPECTrecon overview","title":"Example","text":"To illustrate forward and back projection, it is easiest to start with a simulation example using a digital phantom. The fancy way would be to use a 3D phantom from ImagePhantoms, but instead we just use two simple cubes.\n\nnx,ny,nz = 128,128,80\nT = Float32\nxtrue = zeros(T, nx,ny,nz)\nxtrue[(1nx÷4):(2nx÷3), 1ny÷5:(3ny÷5), 2nz÷6:(3nz÷6)] .= 1\nxtrue[(2nx÷5):(3nx÷5), 1ny÷5:(2ny÷5), 4nz÷6:(5nz÷6)] .= 2\n\naverage(x) = sum(x) / length(x)\nfunction mid3(x::AbstractArray{T,3}) where {T}\n    (nx,ny,nz) = size(x)\n    xy = x[:,:,ceil(Int, nz÷2)]\n    xz = x[:,ceil(Int,end/2),:]\n    zy = x[ceil(Int, nx÷2),:,:]'\n    return [xy xz; zy fill(average(x), nz, nz)]\nend\njim(mid3(xtrue), \"Middle slices of x\")","category":"section"},{"location":"generated/examples/1-overview/#PSF","page":"SPECTrecon overview","title":"PSF","text":"Create a synthetic depth-dependent PSF for a single view\n\npx = 11\npsf1 = psf_gauss( ; ny, px, fwhm_end = 6)\njim(psf1, \"PSF for each of $ny planes\")\n\nIn general the PSF can vary from view to view due to non-circular detector orbits. For simplicity, here we illustrate the case where the PSF is the same for every view.\n\nnview = 60\npsfs = repeat(psf1, 1, 1, 1, nview)\nsize(psfs)\n\nPlan the PSF modeling (see 3-psf.jl)\n\nplan = plan_psf( ; nx, nz, px)","category":"section"},{"location":"generated/examples/1-overview/#Basic-SPECT-forward-projection","page":"SPECTrecon overview","title":"Basic SPECT forward projection","text":"Here is a simple illustration of a SPECT forward projection operation. (This is a memory inefficient way to do it!)\n\ndy = 4 # transaxial pixel size in mm\nmumap = zeros(T, size(xtrue)) # μ-map just zero for illustration here\nviews = project(xtrue, mumap, psfs, dy)\nsize(views)\n\nDisplay the calculated (i.e., simulated) projection views\n\njim(views[:,:,1:4:end], \"Every 4th of $nview projection views\")","category":"section"},{"location":"generated/examples/1-overview/#Basic-SPECT-back-projection","page":"SPECTrecon overview","title":"Basic SPECT back projection","text":"This illustrates an \"unfiltered backprojection\" that leads to a very blurry image (again, with a simple memory inefficient usage).\n\nFirst, back-project two \"rays\" to illustrate the depth-dependent PSF.\n\ntmp = zeros(T, size(views))\ntmp[nx÷2, nz÷2, nview÷5] = 1\ntmp[nx÷2, nz÷2, 1] = 1\ntmp = backproject(tmp, mumap, psfs, dy)\njim(mid3(tmp), \"Back-projection of two rays\")\n\nNow back-project all the views of the phantom.\n\nback = backproject(views, mumap, psfs, dy)\njim(mid3(back), \"Back-projection of ytrue\")","category":"section"},{"location":"generated/examples/1-overview/#Memory-efficiency","page":"SPECTrecon overview","title":"Memory efficiency","text":"For iterative reconstruction, one must do forward and back-projection repeatedly. It is more efficient to pre-allocate work arrays for those operations, instead of repeatedly making system calls.\n\nHere we illustrate the memory efficient versions that are recommended for iterative SPECT reconstruction.\n\nFirst construction the SPECT plan.\n\n#viewangle = (0:(nview-1)) * 2π # default\nplan = SPECTplan(mumap, psfs, dy; T)\n\nMutating version of forward projection:\n\ntmp = Array{T}(undef, nx, nz, nview)\nproject!(tmp, xtrue, plan)\n@assert tmp == views\n\nMutating version of back-projection:\n\ntmp = Array{T}(undef, nx, ny, nz)\nbackproject!(tmp, views, plan)\n@assert tmp ≈ back","category":"section"},{"location":"generated/examples/1-overview/#Using-LinearMapAA","page":"SPECTrecon overview","title":"Using LinearMapAA","text":"Calling project! and backproject! repeatedly leads to application-specific code. More general code uses the fact that SPECT projection and back-projection are linear operations, so we use LinearMapAA to define a \"system matrix\" for these operations.\n\nforw! = (y,x) -> project!(y, x, plan)\nback! = (x,y) -> backproject!(x, y, plan)\nidim = (nx,ny,nz)\nodim = (nx,nz,nview)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\n\nSimple forward and back-projection:\n\n@assert A * xtrue == views\n@assert A' * views ≈ back\n\nMutating version:\n\ntmp = Array{T}(undef, nx, nz, nview)\nmul!(tmp, A, xtrue)\n@assert tmp == views\ntmp = Array{T}(undef, nx, ny, nz)\nmul!(tmp, A', views)\n@assert tmp ≈ back","category":"section"},{"location":"generated/examples/1-overview/#Units","page":"SPECTrecon overview","title":"Units","text":"The pixel dimensions deltas can (and should!) be values with units.\n\nHere is an example with units ... (todo)\n\nusing UnitfulRecipes using Unitful: mm","category":"section"},{"location":"generated/examples/1-overview/#Projection-view-animation","page":"SPECTrecon overview","title":"Projection view animation","text":"anim = @animate for i in 1:nview\n    ymax = maximum(views)\n    jim(views[:,:,i],\n        \"SPECT projection view $i of $nview\",\n        clim = (0, ymax),\n    )\nend\ngif(anim, \"views.gif\", fps = 8)","category":"section"},{"location":"generated/examples/1-overview/#Reproducibility","page":"SPECTrecon overview","title":"Reproducibility","text":"This page was generated with the following version of Julia:\n\nusing InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')\n\nAnd with the following package versions\n\nimport Pkg; Pkg.status()\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/3-psf/#3-psf","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"This page explains the PSF portion of the Julia package SPECTrecon.jl.\n\nThis page comes from a single Julia file: 3-psf.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 3-psf.ipynb, or open it in binder here: 3-psf.ipynb.","category":"section"},{"location":"generated/examples/3-psf/#Setup","page":"SPECTrecon PSF","title":"Setup","text":"Packages needed here.\n\nusing SPECTrecon: psf_gauss, plan_psf, fft_conv!, fft_conv_adj!\nusing MIRTjim: jim, prompt\nusing Plots: scatter, scatter!, plot!, default\ndefault(markerstrokecolor=:auto, markersize=3)\n\nThe following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/3-psf/#Overview","page":"SPECTrecon PSF","title":"Overview","text":"After rotating the image and the attenuation map, second step in SPECT image forward projection is to apply depth-dependent point spread function (PSF). Each (rotated) image plane is a certain distance from the SPECT detector and must be convolved with the 2D PSF appropriate for that plane.\n\nBecause SPECT has relatively poor spatial resolution, the PSF is usually fairly wide, so convolution using FFT operations is typically more efficient than direct spatial convolution.\n\nFollowing other libraries like FFTW.jl, the PSF operations herein start with a plan where work arrays are preallocated for subsequent use. The plan is a Vector of PlanPSF objects: one for each thread. (Parallelism is across planes for a 3D image volume.) The number of threads defaults to Threads.nthreads().","category":"section"},{"location":"generated/examples/3-psf/#Example","page":"SPECTrecon PSF","title":"Example","text":"Start with a 3D image volume.\n\nT = Float32 # work with single precision to save memory\nnx = 32\nnz = 30\nimage = zeros(T, nx, nx, nz) # ny = nx required\nimage[1nx÷4, 1nx÷4, 3nz÷4] = 1\nimage[2nx÷4, 2nx÷4, 2nz÷4] = 1\nimage[3nx÷4, 3nx÷4, 1nz÷4] = 1\njim(image, \"Original image\")\n\nCreate a synthetic gaussian depth-dependent PSF for a single view\n\npx = 11\nnview = 1 # for simplicity in this illustration\npsf = repeat(psf_gauss( ; ny=nx, px), 1, 1, 1, nview)\njim(psf, \"PSF for each of $nx planes\")\n\nNow plan the PSF modeling by specifying\n\nthe image size (must be square)\nthe PSF size: must be px × pz × ny × nview\nthe Type used for the work arrays.\n\nplan = plan_psf( ; nx, nz, px, T)\n\nHere are the internals for the plan for the first thread:\n\nplan[1]\n\nWith this plan pre-allocated, now we can apply the depth-dependent PSF to the image volume (assumed already rotated here).\n\nresult = similar(image) # allocate memory for the result\nfft_conv!(result, image, psf[:,:,:,1], plan) # mutates the first argument\njim(result, \"After applying PSF\")","category":"section"},{"location":"generated/examples/3-psf/#Adjoint","page":"SPECTrecon PSF","title":"Adjoint","text":"To ensure adjoint consistency between SPECT forward- and back-projection, there is also an adjoint routine:\n\nadj = similar(result)\nfft_conv_adj!(adj, result, psf[:,:,:,1], plan)\njim(adj, \"Adjoint of PSF modeling\")\n\nThe adjoint is not the same as the inverse so one does not expect the output here to match the original image!","category":"section"},{"location":"generated/examples/3-psf/#LinearMap","page":"SPECTrecon PSF","title":"LinearMap","text":"One can form a linear map corresponding to PSF modeling using LinearMapAA. Perhaps the main purpose is simply for verifying adjoint correctness.\n\nusing LinearMapsAA: LinearMapAA\n\nnx, nz, px = 10, 7, 5 # small size for illustration\npsf3 = psf_gauss( ; ny=nx, px)\nplan = plan_psf( ; nx, nz, px, T)\nidim = (nx,nx,nz)\nodim = (nx,nx,nz)\nforw! = (y,x) -> fft_conv!(y, x, psf3, plan)\nback! = (x,y) -> fft_conv_adj!(x, y, psf3, plan)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\n\nAfull = Matrix(A)\nAadj = Matrix(A')\njim(cat(dims=3, Afull, Aadj'), \"Linear map for PSF modeling and its adjoint\")\n\nThe following check verifies adjoint consistency:\n\n@assert Afull ≈ Aadj'\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
