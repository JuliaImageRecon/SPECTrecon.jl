<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SPECTrecon rotation · SPECTrecon.jl</title><meta name="title" content="SPECTrecon rotation · SPECTrecon.jl"/><meta property="og:title" content="SPECTrecon rotation · SPECTrecon.jl"/><meta property="twitter:title" content="SPECTrecon rotation · SPECTrecon.jl"/><meta name="description" content="Documentation for SPECTrecon.jl."/><meta property="og:description" content="Documentation for SPECTrecon.jl."/><meta property="twitter:description" content="Documentation for SPECTrecon.jl."/><meta property="og:url" content="https://JuliaImageRecon.github.io/SPECTrecon.jl/stable/generated/examples/2-rotate/"/><meta property="twitter:url" content="https://JuliaImageRecon.github.io/SPECTrecon.jl/stable/generated/examples/2-rotate/"/><link rel="canonical" href="https://JuliaImageRecon.github.io/SPECTrecon.jl/stable/generated/examples/2-rotate/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">SPECTrecon.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../methods/">Methods</a></li><li><a class="tocitem" href="../../../history/">History</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../1-overview/">SPECTrecon overview</a></li><li class="is-active"><a class="tocitem" href>SPECTrecon rotation</a><ul class="internal"><li><a class="tocitem" href="#Setup"><span>Setup</span></a></li><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Adjoint"><span>Adjoint</span></a></li><li><a class="tocitem" href="#LinearMap"><span>LinearMap</span></a></li></ul></li><li><a class="tocitem" href="../3-psf/">SPECTrecon PSF</a></li><li><a class="tocitem" href="../4-mlem/">SPECTrecon ML-EM</a></li><li><a class="tocitem" href="../5-2d/">SPECTrecon 2D use</a></li><li><a class="tocitem" href="../6-dl/">SPECTrecon deep learning use</a></li><li><a class="tocitem" href="../7-osem/">SPECTrecon OS-EM</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>SPECTrecon rotation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SPECTrecon rotation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaImageRecon/SPECTrecon.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaImageRecon/SPECTrecon.jl/blob/main/docs/lit/examples/2-rotate.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="2-rotate"><a class="docs-heading-anchor" href="#2-rotate">SPECTrecon rotation</a><a id="2-rotate-1"></a><a class="docs-heading-anchor-permalink" href="#2-rotate" title="Permalink"></a></h1><p>This page explains the image rotation portion of the Julia package <a href="https://github.com/JuliaImageRecon/SPECTrecon.jl"><code>SPECTrecon.jl</code></a>.</p><p>This page comes from a single Julia file: <a href="https://github.com/JuliaImageRecon/SPECTrecon.jl/blob/main/docs/lit/examples/2-rotate.jl"><code>2-rotate.jl</code></a>.</p><p>You can access the source code for such Julia documentation using the &#39;Edit on GitHub&#39; link in the top right. You can view the corresponding notebook in <a href="https://nbviewer.org/">nbviewer</a> here: <a href="https://nbviewer.org/github/JuliaImageRecon/SPECTrecon.jl/tree/gh-pages/dev/generated/examples/2-rotate.ipynb"><code>2-rotate.ipynb</code></a>, or open it in <a href="https://mybinder.org/">binder</a> here: <a href="https://mybinder.org/v2/gh/JuliaImageRecon/SPECTrecon.jl/gh-pages?filepath=dev/generated/examples/2-rotate.ipynb"><code>2-rotate.ipynb</code></a>.</p><h2 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h2><p>Packages needed here.</p><pre><code class="language-julia hljs">using SPECTrecon: plan_rotate, imrotate!, imrotate_adj!
using MIRTjim: jim, prompt
using Plots: scatter, scatter!, plot!, default
default(markerstrokecolor=:auto, markersize=3)</code></pre><p>The following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.</p><pre><code class="language-julia hljs">isinteractive() ? jim(:prompt, true) : prompt(:draw);</code></pre><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>The first step in SPECT image forward projection is to rotate each slice of a 3D image volume to the appropriate view angle. In principle one could use any of numerous candidate interpolation methods for this task. However, because emission images are nonnegative and maximum likelihood methods for SPECT image reconstruction exploit that nonnegativity, it is desirable to use interpolators that preserve nonnegativity. This constraint rules out quadratic and higher B-splines, including the otherwise attractive cubic B-spline methods. On the other hand, nearest-neighbor interpolation (equivalent to 0th-order B-splines) does not provide adequate image quality. This leaves 1st-order interpolation methods as the most viable options.</p><p>This package supports two 1st-order linear interpolators:</p><ul><li>2D bilinear interpolation,</li><li>a 3-pass rotation method based on 1D linear interpolation.</li></ul><p>Because image rotation is done repeatedly (for every slice of both the emission image and the attenuation map, for both projection and back-projection, and for multiple iterations), it is important for efficiency to use mutating methods rather than to repeatedly make heap allocations.</p><p>Following other libraries like <a href="https://github.com/JuliaMath/FFTW.jl">FFTW.jl</a>, the rotation operations herein start with a <code>plan</code> where work arrays are preallocated for subsequent use. The <code>plan</code> is a <code>Vector</code> of <code>PlanRotate</code> objects: one for each thread. (Parallelism is across slices for a 3D image volume.) The number of threads defaults to <code>Threads.nthreads()</code>.</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Start with a 3D image volume (just 2 slices here for simplicity).</p><pre><code class="language-julia hljs">T = Float32 # work with single precision to save memory
image = zeros(T, 64, 64, 2)
image[30:50,20:30,1] .= 1
image[25:28,20:40,2] .= 1
jim(image, &quot;Original image&quot;)</code></pre><img src="6d654d57.svg" alt="Example block output"/><p>Now plan the rotation by specifying</p><ul><li>the image size <code>nx</code> (it must be square, so <code>ny=nx</code> implicitly)</li><li>the <code>Type</code> used for the work arrays.</li></ul><pre><code class="language-julia hljs">plan2 = plan_rotate(size(image, 1); T)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{PlanRotate{Float32, RotateMode{:two}}} with N=64
</code></pre><p>Here are the internals for the plan for the first thread:</p><pre><code class="language-julia hljs">plan2[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PlanRotate{Float32, RotateMode{:two}}
 nx::Int64 64
 padsize::Int64 15
 interp: LinearInterpolators.SparseInterpolators.SparseInterpolator{Float32, 2, 1}(Float32[1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 94, 94, (94,))
 workmat1: 94×94 Matrix{Float32}
 workmat2: 94×94 Matrix{Float32}
 (72984 bytes)
</code></pre><p>With this <code>plan</code> preallocated, now we can rotate the image volume, specifying the rotation angle in radians:</p><pre><code class="language-julia hljs">result2 = similar(image) # allocate memory for the result
imrotate!(result2, image, π/6, plan2) # mutates the first argument
jim(result2, &quot;Rotated image by π/6 (2D bilinear)&quot;)</code></pre><img src="f94bf5d1.svg" alt="Example block output"/><p>The default, shown above, uses 2D bilinear interpolation for rotation. That default is the recommended approach because it is faster.</p><p>Here is the 3-pass 1D interpolation approach, included mainly for checking consistency with the historical ASPIRE approach used in Matlab version of MIRT.</p><pre><code class="language-julia hljs">plan1 = plan_rotate(size(image, 1); T, method=:one)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{PlanRotate{Float32, RotateMode{:one}}} with N=64
</code></pre><p>Here are the plan internals for the first thread:</p><pre><code class="language-julia hljs">plan1[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PlanRotate{Float32, RotateMode{:one}}
 nx::Int64 64
 padsize::Int64 15
 interp: LinearInterpolators.SparseInterpolators.SparseInterpolator{Float32, 2, 1}(Float32[1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 94, 94, (94,))
 workmat1: 94×94 Matrix{Float32}
 workmat2: 94×94 Matrix{Float32}
 (72984 bytes)
</code></pre><p>The results of rotation using 3-pass 1D interpolation look quite similar:</p><pre><code class="language-julia hljs">result1 = similar(image)
imrotate!(result1, image, π/6, plan1)
jim(result1, &quot;Rotated image by π/6 (3-pass 1D)&quot;)</code></pre><img src="c6fc838a.svg" alt="Example block output"/><p>Here are the difference images for comparison.</p><pre><code class="language-julia hljs">jim(result1 - result2, &quot;Difference images&quot;)</code></pre><img src="f458a02f.svg" alt="Example block output"/><h2 id="Adjoint"><a class="docs-heading-anchor" href="#Adjoint">Adjoint</a><a id="Adjoint-1"></a><a class="docs-heading-anchor-permalink" href="#Adjoint" title="Permalink"></a></h2><p>To ensure adjoint consistency between SPECT forward- and back-projection, there is also an adjoint routine:</p><pre><code class="language-julia hljs">adj2 = similar(result2)
imrotate_adj!(adj2, result2, π/6, plan2)
jim(adj2, &quot;Adjoint image rotation (2D)&quot;)

adj1 = similar(result1)
imrotate_adj!(adj1, result1, π/6, plan1)
jim(adj1, &quot;Adjoint image rotation (3-pass 1D)&quot;)</code></pre><img src="ecb6e16b.svg" alt="Example block output"/><p>The adjoint is <em>not</em> the same as the inverse so one does not expect the output here to match the original image!</p><h2 id="LinearMap"><a class="docs-heading-anchor" href="#LinearMap">LinearMap</a><a id="LinearMap-1"></a><a class="docs-heading-anchor-permalink" href="#LinearMap" title="Permalink"></a></h2><p>One can form a linear map corresponding to image rotation using <code>LinearMapAA</code>. An operator like this may be useful as part of a motion-compensated image reconstruction method.</p><pre><code class="language-julia hljs">using LinearMapsAA: LinearMapAA

nx = 20 # small size for illustration
r1 = plan_rotate(nx; T, nthread = 1, method=:two)[1]
r2 = plan_rotate(nx; T, nthread = 1, method=:one)[1]
idim = (nx,nx)
odim = (nx,nx)
forw! = (y,x) -&gt; imrotate!(y, x, π/6, r1)
back! = (x,y) -&gt; imrotate_adj!(x, y, π/6, r1)
A1 = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)
forw! = (y,x) -&gt; imrotate!(y, x, π/6, r2)
back! = (x,y) -&gt; imrotate_adj!(x, y, π/6, r2)
A2 = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)

Afull1 = Matrix(A1)
Aadj1 = Matrix(A1&#39;)
Afull2 = Matrix(A2)
Aadj2 = Matrix(A2&#39;)
jim(cat(dims=3, Afull1&#39;, Aadj1&#39;, Afull2&#39;, Aadj2&#39;), &quot;Linear map for 2D rotation and its adjoint&quot;)</code></pre><img src="56319769.svg" alt="Example block output"/><p>The following verify adjoint consistency:</p><pre><code class="language-julia hljs">@assert Afull1&#39; ≈ Aadj1
@assert Afull2&#39; ≈ Aadj2</code></pre><p>Applying this linear map to a 2D or 3D image performs rotation:</p><pre><code class="language-julia hljs">image2 = zeros(nx,nx); image2[4:6, 5:13] .= 1
jim(cat(dims=3, image2, A2 * image2), &quot;Rotation via linear map: 2D&quot;)</code></pre><img src="b0684ade.svg" alt="Example block output"/><p>Here is 3D too. The <code>A2 * image3</code> here uses the advanced &quot;operator&quot; feature of <a href="https://github.com/JeffFessler/LinearMapsAA.jl">LinearMapsAA.jl</a>.</p><pre><code class="language-julia hljs">image3 = cat(dims=3, image2, image2&#39;)
jim(cat(dims=4, image3, A2 * image3), &quot;Rotation via linear map: 3D&quot;)</code></pre><img src="d0cdee69.svg" alt="Example block output"/><p>Examine row and column sums of linear map</p><pre><code class="language-julia hljs">scatter(xlabel=&quot;pixel index&quot;, ylabel=&quot;row or col sum&quot;)
scatter!(vec(sum(Afull1, dims=1)), label=&quot;dim1 sum1&quot;, marker=:x)
scatter!(vec(sum(Afull1, dims=2)), label=&quot;dim2 sum1&quot;, marker=:square)
scatter!(vec(sum(Afull2, dims=1)), label=&quot;dim1 sum2&quot;)
scatter!(vec(sum(Afull2, dims=2)), label=&quot;dim2 sum2&quot;)</code></pre><img src="715053b1.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../1-overview/">« SPECTrecon overview</a><a class="docs-footer-nextpage" href="../3-psf/">SPECTrecon PSF »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Tuesday 11 March 2025 15:55">Tuesday 11 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
