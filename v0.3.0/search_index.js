var documenterSearchIndex = {"docs":
[{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"EditURL = \"../../../lit/examples/5-2d.jl\"","category":"page"},{"location":"generated/examples/5-2d/#5-2d","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"","category":"section"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"This page describes how to perform 2D SPECT forward and back-projection using the Julia package SPECTrecon.","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"This page comes from a single Julia file: 5-2d.jl.","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"You can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 5-2d.ipynb, or open it in binder here: 5-2d.ipynb.","category":"page"},{"location":"generated/examples/5-2d/#Setup","page":"SPECTrecon 2D use","title":"Setup","text":"","category":"section"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Packages needed here.","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"using SPECTrecon: SPECTplan, psf_gauss\nusing SPECTrecon: project, project!, backproject, backproject!\nusing MIRTjim: jim, prompt\nusing ImagePhantoms: shepp_logan, SheppLoganEmis\nusing LinearAlgebra: mul!\nusing LinearMapsAA: LinearMapAA\nusing Plots: plot, default; default(markerstrokecolor=:auto)","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"The following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/5-2d/#Overview","page":"SPECTrecon 2D use","title":"Overview","text":"","category":"section"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Real SPECT systems are inherently 3D imaging systems, but for the purpose of prototyping algorithms it can be useful to work with 2D simulations.","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Currently, \"2D\" here means a 3D array with nz=1, i.e., a single slice. The key to working with a single slice is that the package allows the PSFs to have rectangular support px × pz where pz = 1, i.e., no blur along the axial (z) direction.","category":"page"},{"location":"generated/examples/5-2d/#Example","page":"SPECTrecon 2D use","title":"Example","text":"","category":"section"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Start with a simple 2D digital phantom.","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"T = Float32\nnx,ny,nz = 128,128,1\nxtrue = T.(shepp_logan(nx, SheppLoganEmis()))\nxtrue = reshape(xtrue, nx, ny, 1) # 3D array with nz=1\njim(xtrue, \"xtrue: SheppLoganEmis with size $(size(xtrue))\")","category":"page"},{"location":"generated/examples/5-2d/#PSF","page":"SPECTrecon 2D use","title":"PSF","text":"","category":"section"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Create a synthetic depth-dependent PSF for a single view","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"px,pz = 11,1 # pz=1 is crucial for 2D work\npsf1 = psf_gauss( ; ny, px, pz, fwhm_start = 1, fwhm_end = 4) # (px,pz,ny)\ntmp = reshape(psf1, px, ny) / maximum(psf1) # (px,ny)\nhx = (px-1)÷2\nplot(-hx:hx, tmp[:,[1:9:end-10;end]], markershape=:o, label=\"\",\n    title = \"Depth-dependent PSF profiles\",\n    xtick = [-hx, -2, 0, 2, hx], # (-1:1) .* ((px-1)÷2),\n    ytick = [0; round.(tmp[hx+1,end] * [0.5,1], digits=2); 0.5; 1],\n)\nprompt()","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"In general the PSF can vary from view to view due to non-circular detector orbits. For simplicity, here we illustrate the case where the PSF is the same for every view.","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"nview = 80\npsfs = repeat(psf1, 1, 1, 1, nview)\nsize(psfs)","category":"page"},{"location":"generated/examples/5-2d/#Basic-SPECT-forward-projection","page":"SPECTrecon 2D use","title":"Basic SPECT forward projection","text":"","category":"section"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Here is a simple illustration of a SPECT forward projection operation. (This is a memory inefficient way to do it!)","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"dy = 4 # transaxial pixel size in mm\nmumap = zeros(T, size(xtrue)) # μ-map just zero for illustration here\nviews = project(xtrue, mumap, psfs, dy) # [nx,1,nview]\nsino = reshape(views, nx, nview)\nsize(sino)","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Display the calculated (i.e., simulated) projection views","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"jim(sino, \"Sinogram\")","category":"page"},{"location":"generated/examples/5-2d/#Basic-SPECT-back-projection","page":"SPECTrecon 2D use","title":"Basic SPECT back projection","text":"","category":"section"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"This illustrates an \"unfiltered backprojection\" that leads to a very blurry image (again, with a simple memory inefficient usage).","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"First, back-project two \"rays\" to illustrate the depth-dependent PSF.","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"sino1 = zeros(T, nx, nview)\nsino1[nx÷2, nview÷5] = 1\nsino1[nx÷2, 1] = 1\nsino1 = reshape(sino1, nx, nz, nview)\nback1 = backproject(sino1, mumap, psfs, dy)\njim(back1, \"Back-projection of two rays\")","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Now back-project all the views of the phantom.","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"back = backproject(views, mumap, psfs, dy)\njim(back, \"Back-projection of ytrue\")","category":"page"},{"location":"generated/examples/5-2d/#Memory-efficiency","page":"SPECTrecon 2D use","title":"Memory efficiency","text":"","category":"section"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"For iterative reconstruction, one must do forward and back-projection repeatedly. It is more efficient to pre-allocate work arrays for those operations, instead of repeatedly making system calls.","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Here we illustrate the memory efficient versions that are recommended for iterative SPECT reconstruction.","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"First construction the SPECT plan.","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"#viewangle = (0:(nview-1)) * 2π # default\nplan = SPECTplan(mumap, psfs, dy; T)","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Mutating version of forward projection:","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"tmp = Array{T}(undef, nx, nz, nview)\nproject!(tmp, xtrue, plan)\n@assert tmp == views","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Mutating version of back-projection:","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"tmp = Array{T}(undef, nx, ny, nz)\nbackproject!(tmp, views, plan)\n@assert tmp ≈ back","category":"page"},{"location":"generated/examples/5-2d/#Using-LinearMapsAA","page":"SPECTrecon 2D use","title":"Using LinearMapsAA","text":"","category":"section"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Calling project! and backproject! repeatedly leads to application-specific code. More general code uses the fact that SPECT projection and back-projection are linear operations, so we use LinearMapAA to define a \"system matrix\" for these operations.","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"forw! = (y,x) -> project!(y, x, plan)\nback! = (x,y) -> backproject!(x, y, plan)\nidim = (nx,ny,nz)\nodim = (nx,nz,nview)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Simple forward and back-projection:","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"@assert A * xtrue == views\n@assert A' * views ≈ back","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"Mutating version:","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"tmp = Array{T}(undef, nx, nz, nview)\nmul!(tmp, A, xtrue)\n@assert tmp == views\ntmp = Array{T}(undef, nx, ny, nz)\nmul!(tmp, A', views)\n@assert tmp ≈ back","category":"page"},{"location":"generated/examples/5-2d/#Gram-matrix-impulse-response","page":"SPECTrecon 2D use","title":"Gram matrix impulse response","text":"","category":"section"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"points = zeros(T, nx, ny, nz)\npoints[nx÷2,ny÷2,1] = 1\npoints[3nx÷4,ny÷4,1] = 1\n\nimpulse = A' * (A * points)\njim(impulse, \"Impulse response of A'A\")","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"","category":"page"},{"location":"generated/examples/5-2d/","page":"SPECTrecon 2D use","title":"SPECTrecon 2D use","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"EditURL = \"../../../lit/examples/7-osem.jl\"","category":"page"},{"location":"generated/examples/7-osem/#7-osem","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"","category":"section"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"This page illustrates Ordered-subset expectation-maximization (OS-EM) image reconstruction with the Julia package SPECTrecon.","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"This page comes from a single Julia file: 7-osem.jl.","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"You can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 7-osem.ipynb, or open it in binder here: 7-osem.ipynb.","category":"page"},{"location":"generated/examples/7-osem/#Setup","page":"SPECTrecon OS-EM","title":"Setup","text":"","category":"section"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"Packages needed here.","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"using SPECTrecon: psf_gauss, SPECTplan, project!, backproject!, Ablock\nusing SPECTrecon: osem, osem!, mlem!\nusing LinearMapsAA: LinearMapAA, LinearMapAO\nusing LinearAlgebra: mul!\nusing Distributions: Poisson\nusing MIRTjim: jim, prompt\nusing Plots: scatter, plot!, default; default(markerstrokecolor=:auto)","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"The following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/7-osem/#Overview","page":"SPECTrecon OS-EM","title":"Overview","text":"","category":"section"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"Ordered-subset expectation-maximization (OS-EM) is a commonly used algorithm for performing SPECT image reconstruction because of its favorable combination of image quality and speed. See Hudson and Larkin, 1994.","category":"page"},{"location":"generated/examples/7-osem/#Simulation-data","page":"SPECTrecon OS-EM","title":"Simulation data","text":"","category":"section"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"nx,ny,nz = 64,64,50\nT = Float32\nxtrue = zeros(T, nx,ny,nz) # simple phantom\nxtrue[(1nx÷4):(2nx÷3), 1ny÷5:(3ny÷5), 2nz÷6:(3nz÷6)] .= 1\nxtrue[(2nx÷5):(3nx÷5), 1ny÷5:(2ny÷5), 4nz÷6:(5nz÷6)] .= 2\n\naverage(x) = sum(x) / length(x)\nfunction mid3(x::AbstractArray{<:Number,3}) # 3 central planes\n    (nx,ny,nz) = size(x)\n    xy = x[:,:,ceil(Int, nz÷2)]\n    xz = x[:,ceil(Int,end/2),:]\n    zy = x[ceil(Int, nx÷2),:,:]'\n    return [xy xz; zy fill(average(xy), nz, nz)]\nend\njim(mid3(xtrue), \"Middle slices of xtrue\")","category":"page"},{"location":"generated/examples/7-osem/#PSF","page":"SPECTrecon OS-EM","title":"PSF","text":"","category":"section"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"Create a synthetic depth-dependent PSF for a single view","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"px = 11\npsf1 = psf_gauss( ; ny, px)\njim(psf1, \"PSF for each of $ny planes\"; ratio=1)","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"In general the PSF can vary from view to view due to non-circular detector orbits. For simplicity, here we illustrate the case where the PSF is the same for every view.","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"nview = 60\npsfs = repeat(psf1, 1, 1, 1, nview)\nsize(psfs)","category":"page"},{"location":"generated/examples/7-osem/#SPECT-system-model-using-LinearMapAA","page":"SPECTrecon OS-EM","title":"SPECT system model using LinearMapAA","text":"","category":"section"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"dy = 8 # transaxial pixel size in mm\nmumap = zeros(T, size(xtrue)) # zero μ-map just for illustration here\nplan = SPECTplan(mumap, psfs, dy; T)\n\nforw! = (y,x) -> project!(y, x, plan)\nback! = (x,y) -> backproject!(x, y, plan)\nidim = (nx,ny,nz)\nodim = (nx,nz,nview)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"Noisy data","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"if !@isdefined(ynoisy) # generate (scaled) Poisson data\n    ytrue = A * xtrue\n    target_mean = 20 # aim for mean of 20 counts per ray\n    scale = target_mean / average(ytrue)\n    scatter_fraction = 0.1 # 10% uniform scatter for illustration\n    scatter_mean = scatter_fraction * average(ytrue) # uniform for simplicity\n    background = scatter_mean * ones(T,nx,nz,nview)\n    ynoisy = rand.(Poisson.(scale * (ytrue + background))) / scale\nend\njim(ynoisy, \"$nview noisy projection views\")","category":"page"},{"location":"generated/examples/7-osem/#OS-EM-algorithm-basic-version","page":"SPECTrecon OS-EM","title":"OS-EM algorithm - basic version","text":"","category":"section"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"x0 = ones(T, nx, ny, nz) # initial uniform image\n\nniter = 8\nnblocks = 4\nAb = Ablock(plan, nblocks) # create a linear map for each block\n\nif !@isdefined(xhat1)\n    xhat1 = osem(x0, ynoisy, background, Ab; niter)\nend;\nnothing #hide","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"This preferable OS-EM version preallocates the output xhat2:","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"if !@isdefined(xhat2)\n    xhat2 = copy(x0)\n    osem!(xhat2, x0, ynoisy, background, Ab; niter)\nend\n\n@assert xhat1 ≈ xhat2","category":"page"},{"location":"generated/examples/7-osem/#Compare-with-ML-EM","page":"SPECTrecon OS-EM","title":"Compare with ML-EM","text":"","category":"section"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"Run 30 iterations of ML-EM algorithm.","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"niter_mlem = 30\nif !@isdefined(xhat3)\n    xhat3 = copy(x0)\n    mlem!(xhat3, x0, ynoisy, background, A; niter=niter_mlem)\nend\n\njim(jim(mid3(xhat2), \"OS-EM at $niter iterations\"),\n    jim(mid3(xhat3), \"ML-EM at $niter_mlem iterations\"))","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"","category":"page"},{"location":"generated/examples/7-osem/","page":"SPECTrecon OS-EM","title":"SPECTrecon OS-EM","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"EditURL = \"../../../lit/examples/2-rotate.jl\"","category":"page"},{"location":"generated/examples/2-rotate/#2-rotate","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"","category":"section"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"This page explains the image rotation portion of the Julia package SPECTrecon.jl.","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"This page comes from a single Julia file: 2-rotate.jl.","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"You can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 2-rotate.ipynb, or open it in binder here: 2-rotate.ipynb.","category":"page"},{"location":"generated/examples/2-rotate/#Setup","page":"SPECTrecon rotation","title":"Setup","text":"","category":"section"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Packages needed here.","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"using SPECTrecon: plan_rotate, imrotate!, imrotate_adj!\nusing MIRTjim: jim, prompt\nusing Plots: scatter, scatter!, plot!, default\ndefault(markerstrokecolor=:auto, markersize=3)","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/2-rotate/#Overview","page":"SPECTrecon rotation","title":"Overview","text":"","category":"section"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The first step in SPECT image forward projection is to rotate each slice of a 3D image volume to the appropriate view angle. In principle one could use any of numerous candidate interpolation methods for this task. However, because emission images are nonnegative and maximum likelihood methods for SPECT image reconstruction exploit that nonnegativity, it is desirable to use interpolators that preserve nonnegativity. This constraint rules out quadratic and higher B-splines, including the otherwise attractive cubic B-spline methods. On the other hand, nearest-neighbor interpolation (equivalent to 0th-order B-splines) does not provide adequate image quality. This leaves 1st-order interpolation methods as the most viable options.","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"This package supports two 1st-order linear interpolators:","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"2D bilinear interpolation,\na 3-pass rotation method based on 1D linear interpolation.","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Because image rotation is done repeatedly (for every slice of both the emission image and the attenuation map, for both projection and back-projection, and for multiple iterations), it is important for efficiency to use mutating methods rather than to repeatedly make heap allocations.","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Following other libraries like FFTW.jl, the rotation operations herein start with a plan where work arrays are preallocated for subsequent use. The plan is a Vector of PlanRotate objects: one for each thread. (Parallelism is across slices for a 3D image volume.) The number of threads defaults to Threads.nthreads().","category":"page"},{"location":"generated/examples/2-rotate/#Example","page":"SPECTrecon rotation","title":"Example","text":"","category":"section"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Start with a 3D image volume (just 2 slices here for simplicity).","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"T = Float32 # work with single precision to save memory\nimage = zeros(T, 64, 64, 2)\nimage[30:50,20:30,1] .= 1\nimage[25:28,20:40,2] .= 1\njim(image, \"Original image\")","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Now plan the rotation by specifying","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"the image size nx (it must be square, so ny=nx implicitly)\nthe Type used for the work arrays.","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"plan2 = plan_rotate(size(image, 1); T)","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here are the internals for the plan for the first thread:","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"plan2[1]","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"With this plan preallocated, now we can rotate the image volume, specifying the rotation angle in radians:","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"result2 = similar(image) # allocate memory for the result\nimrotate!(result2, image, π/6, plan2) # mutates the first argument\njim(result2, \"Rotated image by π/6 (2D bilinear)\")","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The default, shown above, uses 2D bilinear interpolation for rotation. That default is the recommended approach because it is faster.","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here is the 3-pass 1D interpolation approach, included mainly for checking consistency with the historical ASPIRE approach used in Matlab version of MIRT.","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"plan1 = plan_rotate(size(image, 1); T, method=:one)","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here are the plan internals for the first thread:","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"plan1[1]","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The results of rotation using 3-pass 1D interpolation look quite similar:","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"result1 = similar(image)\nimrotate!(result1, image, π/6, plan1)\njim(result1, \"Rotated image by π/6 (3-pass 1D)\")","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here are the difference images for comparison.","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"jim(result1 - result2, \"Difference images\")","category":"page"},{"location":"generated/examples/2-rotate/#Adjoint","page":"SPECTrecon rotation","title":"Adjoint","text":"","category":"section"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"To ensure adjoint consistency between SPECT forward- and back-projection, there is also an adjoint routine:","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"adj2 = similar(result2)\nimrotate_adj!(adj2, result2, π/6, plan2)\njim(adj2, \"Adjoint image rotation (2D)\")\n\nadj1 = similar(result1)\nimrotate_adj!(adj1, result1, π/6, plan1)\njim(adj1, \"Adjoint image rotation (3-pass 1D)\")","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The adjoint is not the same as the inverse so one does not expect the output here to match the original image!","category":"page"},{"location":"generated/examples/2-rotate/#LinearMap","page":"SPECTrecon rotation","title":"LinearMap","text":"","category":"section"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"One can form a linear map corresponding to image rotation using LinearMapAA. An operator like this may be useful as part of a motion-compensated image reconstruction method.","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"using LinearMapsAA: LinearMapAA\n\nnx = 20 # small size for illustration\nr1 = plan_rotate(nx; T, nthread = 1, method=:two)[1]\nr2 = plan_rotate(nx; T, nthread = 1, method=:one)[1]\nidim = (nx,nx)\nodim = (nx,nx)\nforw! = (y,x) -> imrotate!(y, x, π/6, r1)\nback! = (x,y) -> imrotate_adj!(x, y, π/6, r1)\nA1 = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\nforw! = (y,x) -> imrotate!(y, x, π/6, r2)\nback! = (x,y) -> imrotate_adj!(x, y, π/6, r2)\nA2 = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\n\nAfull1 = Matrix(A1)\nAadj1 = Matrix(A1')\nAfull2 = Matrix(A2)\nAadj2 = Matrix(A2')\njim(cat(dims=3, Afull1', Aadj1', Afull2', Aadj2'), \"Linear map for 2D rotation and its adjoint\")","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"The following verify adjoint consistency:","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"@assert Afull1' ≈ Aadj1\n@assert Afull2' ≈ Aadj2","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Applying this linear map to a 2D or 3D image performs rotation:","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"image2 = zeros(nx,nx); image2[4:6, 5:13] .= 1\njim(cat(dims=3, image2, A2 * image2), \"Rotation via linear map: 2D\")","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Here is 3D too. The A2 * image3 here uses the advanced \"operator\" feature of LinearMapsAA.jl.","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"image3 = cat(dims=3, image2, image2')\njim(cat(dims=4, image3, A2 * image3), \"Rotation via linear map: 3D\")","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"Examine row and column sums of linear map","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"scatter(xlabel=\"pixel index\", ylabel=\"row or col sum\")\nscatter!(vec(sum(Afull1, dims=1)), label=\"dim1 sum1\", marker=:x)\nscatter!(vec(sum(Afull1, dims=2)), label=\"dim2 sum1\", marker=:square)\nscatter!(vec(sum(Afull2, dims=1)), label=\"dim1 sum2\")\nscatter!(vec(sum(Afull2, dims=2)), label=\"dim2 sum2\")","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"","category":"page"},{"location":"generated/examples/2-rotate/","page":"SPECTrecon rotation","title":"SPECTrecon rotation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"EditURL = \"../../../lit/examples/6-dl.jl\"","category":"page"},{"location":"generated/examples/6-dl/#6-dl","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"","category":"section"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"This page describes how to end-to-end train unrolled deep learning algorithms using the Julia package SPECTrecon.","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"This page comes from a single Julia file: 6-dl.jl.","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"You can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 6-dl.ipynb, or open it in binder here: 6-dl.ipynb.","category":"page"},{"location":"generated/examples/6-dl/#Setup","page":"SPECTrecon deep learning use","title":"Setup","text":"","category":"section"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"Packages needed here.","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"using LinearAlgebra: norm, mul!\nusing SPECTrecon: SPECTplan, project!, backproject!, psf_gauss, mlem!\nusing MIRTjim: jim, prompt\nusing Plots: default; default(markerstrokecolor=:auto)\nusing ZygoteRules: @adjoint\nusing Flux: Chain, Conv, SamePad, relu, params, unsqueeze\nimport Flux # apparently needed for BSON @load\nimport NNlib\nusing LinearMapsAA: LinearMapAA\nusing Distributions: Poisson\nusing BSON: @load, @save\nimport BSON # load\nusing InteractiveUtils: versioninfo\nimport Downloads # download","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"The following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/6-dl/#Overview","page":"SPECTrecon deep learning use","title":"Overview","text":"","category":"section"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"Regularized expectation-maximization (reg-EM) is a commonly used algorithm for performing SPECT image reconstruction. This page considers regularizers of the form β2 * x - u^2, where u is an auxiliary variable that often refers to the image denoised by a CNN.","category":"page"},{"location":"generated/examples/6-dl/#Data-generation","page":"SPECTrecon deep learning use","title":"Data generation","text":"","category":"section"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"Simulated data used in this page are identical to SPECTrecon ML-EM. We repeat it again here for convenience.","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"nx,ny,nz = 64,64,50\nT = Float32\nxtrue = zeros(T, nx,ny,nz)\nxtrue[(1nx÷4):(2nx÷3), 1ny÷5:(3ny÷5), 2nz÷6:(3nz÷6)] .= 1\nxtrue[(2nx÷5):(3nx÷5), 1ny÷5:(2ny÷5), 4nz÷6:(5nz÷6)] .= 2\n\naverage(x) = sum(x) / length(x)\nfunction mid3(x::AbstractArray{T,3}) where {T}\n    (nx,ny,nz) = size(x)\n    xy = x[:,:,ceil(Int, nz÷2)]\n    xz = x[:,ceil(Int,end/2),:]\n    zy = x[ceil(Int, nx÷2),:,:]'\n    return [xy xz; zy fill(average(xy), nz, nz)]\nend\njim(mid3(xtrue), \"Middle slices of xtrue\")","category":"page"},{"location":"generated/examples/6-dl/#PSF","page":"SPECTrecon deep learning use","title":"PSF","text":"","category":"section"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"Create a synthetic depth-dependent PSF for a single view","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"px = 11\npsf1 = psf_gauss( ; ny, px)\njim(psf1, \"PSF for each of $ny planes\")","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"In general the PSF can vary from view to view due to non-circular detector orbits. For simplicity, here we illustrate the case where the PSF is the same for every view.","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"nview = 60\npsfs = repeat(psf1, 1, 1, 1, nview)\nsize(psfs)","category":"page"},{"location":"generated/examples/6-dl/#SPECT-system-model-using-LinearMapAA","page":"SPECTrecon deep learning use","title":"SPECT system model using LinearMapAA","text":"","category":"section"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"dy = 8 # transaxial pixel size in mm\nmumap = zeros(T, size(xtrue)) # zero μ-map just for illustration here\nplan = SPECTplan(mumap, psfs, dy; T)\n\nforw! = (y,x) -> project!(y, x, plan)\nback! = (x,y) -> backproject!(x, y, plan)\nidim = (nx,ny,nz)\nodim = (nx,nz,nview)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"Generate noisy data","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"if !@isdefined(ynoisy) # generate (scaled) Poisson data\n    ytrue = A * xtrue\n    target_mean = 20 # aim for mean of 20 counts per ray\n    scale = target_mean / average(ytrue)\n    scatter_fraction = 0.1 # 10% uniform scatter for illustration\n    scatter_mean = scatter_fraction * average(ytrue) # uniform for simplicity\n    background = scatter_mean * ones(T,nx,nz,nview)\n    ynoisy = rand.(Poisson.(scale * (ytrue + background))) / scale\nend\njim(ynoisy, \"$nview noisy projection views\"; ncol=10)","category":"page"},{"location":"generated/examples/6-dl/#ML-EM-algorithm","page":"SPECTrecon deep learning use","title":"ML-EM algorithm","text":"","category":"section"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"x0 = ones(T, nx, ny, nz) # initial uniform image\n\nniter = 30\n\nif !@isdefined(xhat1)\n    xhat1 = copy(x0)\n    mlem!(xhat1, x0, ynoisy, background, A; niter)\nend;\nnothing #hide","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"Define evaluation metric","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"nrmse(x) = round(100 * norm(mid3(x) - mid3(xtrue)) / norm(mid3(xtrue)); digits=1)\nprompt()\n# jim(mid3(xhat1), \"MLEM NRMSE=$(nrmse(xhat1))%\") # display ML-EM reconstructed image","category":"page"},{"location":"generated/examples/6-dl/#Implement-a-3D-CNN-denoiser","page":"SPECTrecon deep learning use","title":"Implement a 3D CNN denoiser","text":"","category":"section"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"cnn = Chain(\n    Conv((3,3,3), 1 => 4, relu; stride = 1, pad = SamePad(), bias = true),\n    Conv((3,3,3), 4 => 4, relu; stride = 1, pad = SamePad(), bias = true),\n    Conv((3,3,3), 4 => 1; stride = 1, pad = SamePad(), bias = true),\n)","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"Show how many parameters the CNN has","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"paramCount = sum([sum(length, params(layer)) for layer in cnn])","category":"page"},{"location":"generated/examples/6-dl/#Custom-backpropagation","page":"SPECTrecon deep learning use","title":"Custom backpropagation","text":"","category":"section"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"Forward and back-projection are linear operations so their Jacobians are very simple and there is no need to auto-differentiate through the system matrix and that would be very computationally expensive. Instead, we tell Flux.jl to use the customized Jacobian when doing backpropagation.","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"projectb(x) = A * x\n@adjoint projectb(x) = A * x, dy -> (A' * dy, )\n\nbackprojectb(y) = A' * y\n@adjoint backprojectb(y) = A' * y, dx -> (A * dx, )","category":"page"},{"location":"generated/examples/6-dl/#Backpropagatable-regularized-EM-algorithm","page":"SPECTrecon deep learning use","title":"Backpropagatable regularized EM algorithm","text":"","category":"section"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"First define a function for unsqueezing the data because Flux CNN model expects a 5-dim tensor","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"function unsqueeze45(x)\n    return unsqueeze(unsqueeze(x, 4), 5)\nend\n\n\"\"\"\n    bregem(projectb, backprojectb, y, r, Asum, x, cnn, β; niter = 1)\n\nBackpropagatable regularized EM reconstruction with CNN regularization\n-`projectb`: backpropagatable forward projection\n-`backprojectb`: backpropagatable backward projection\n-`y`: projections\n-`r`: scatters\n-`Asum`: A' * 1\n-`x`: current iterate\n-`cnn`: the CNN model\n-`β`: regularization parameter\n-`niter`: number of iteration for inner EM\n\"\"\"\nfunction bregem(\n    projectb::Function,\n    backprojectb::Function,\n    y::AbstractArray,\n    r::AbstractArray,\n    Asum::AbstractArray,\n    x::AbstractArray,\n    cnn::Union{Chain,Function},\n    β::Real;\n    niter::Int = 1,\n)\n\n    u = cnn(unsqueeze45(x))[:,:,:,1,1]\n    Asumu = Asum - β * u\n    Asumu2 = Asumu.^2\n    T = eltype(x)\n    for iter = 1:niter\n        eterm = backprojectb((y ./ (projectb(x) + r)))\n        eterm_beta = 4 * β * (x .* eterm)\n        x = max.(0, T(1/2β) * (-Asumu + sqrt.(Asumu2 + eterm_beta)))\n    end\n    return x\nend","category":"page"},{"location":"generated/examples/6-dl/#Loss-function","page":"SPECTrecon deep learning use","title":"Loss function","text":"","category":"section"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"We set β = 1 and train 2 outer iterations.","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"β = 1\nAsum = A' * ones(T, nx, nz, nview)\nfunction loss(xrecon, xtrue)\n    xiter1 = bregem(projectb, backprojectb, ynoisy, background,\n                    Asum, xrecon, cnn, β; niter = 1)\n    xiter2 = bregem(projectb, backprojectb, ynoisy, background,\n                    Asum, xiter1, cnn, β; niter = 1)\n    return sum(abs2, xiter2 - xtrue)\nend","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"Initial loss","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"@show loss(xhat1, xtrue)","category":"page"},{"location":"generated/examples/6-dl/#Train-the-CNN","page":"SPECTrecon deep learning use","title":"Train the CNN","text":"","category":"section"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"Uncomment the following code to train:","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"using Printf\nnepoch = 200\nfor e in 1:nepoch\n    @printf(\"epoch = %d, loss = %.2f\\n\", e, loss(xhat1, xtrue))\n    ps = Flux.params(cnn)\n    gs = gradient(ps) do\n        loss(xhat1, xtrue) # we start with the 30 iteration EM reconstruction\n    end\n    opt = ADAMW(0.002)\n    Flux.Optimise.update!(opt, ps, gs)\nend","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"Uncomment to save your trained model:","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"file = \"../data/trained-cnn-example-6-dl.bson\" # adjust path/name as needed\n@save file cnn","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"Load the pre-trained model (uncomment if you save your own model):","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"@load file cnn","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"The code below here works fine when run via include from the REPL, but it fails with the error UndefVarError: NNlib not defined on the BSON.load step when run via Literate/Documenter. So for now it is just fenced off with isinteractive().","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"if isinteractive()\n    url = \"https://github.com/JuliaImageRecon/SPECTrecon.jl/blob/main/data/trained-cnn-example-6-dl.bson?raw=true\"\n    tmp = tempname()\n    Downloads.download(url, tmp)\n    cnn = BSON.load(tmp)[:cnn]\nelse\n    cnn = x -> x # fake \"do-nothing CNN\" for Literate/Documenter version\nend","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"Perform recon with pre-trained model.","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"xiter1 = bregem(projectb, backprojectb, ynoisy, background,\n                Asum, xhat1, cnn, β; niter = 1)\nxiter2 = bregem(projectb, backprojectb, ynoisy, background,\n                Asum, xiter1, cnn, β; niter = 1)\n\nclim = (0,2)\njim(\n    jim(mid3(xtrue), \"xtrue\"; clim),\n    jim(mid3(xhat1), \"EM recon, NRMSE = $(nrmse(xhat1))%\"; clim),\n    jim(mid3(xiter1), \"Iter 1, NRMSE = $(nrmse(xiter1))%\"; clim),\n    jim(mid3(xiter2), \"Iter 2, NRMSE = $(nrmse(xiter2))%\"; clim),\n)","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"For the web-based Documenter/Literate version, the three NRMSE values will be the same because of the \"do-nothing\" CNN above. But if you download this file and run it locally, then you will see that the CNN reduces the NRMSE.","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"A more thorough investigation would compare the CNN approach to a suitably optimized regularized approach; see https://doi.org/10.1109/EMBC46164.2021.9630985.","category":"page"},{"location":"generated/examples/6-dl/#Reproducibility","page":"SPECTrecon deep learning use","title":"Reproducibility","text":"","category":"section"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"This page was generated with the following version of Julia:","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"using InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"And with the following package versions","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"import Pkg; Pkg.status()","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"","category":"page"},{"location":"generated/examples/6-dl/","page":"SPECTrecon deep learning use","title":"SPECTrecon deep learning use","text":"This page was generated using Literate.jl.","category":"page"},{"location":"history/#History","page":"History","title":"History","text":"","category":"section"},{"location":"history/","page":"History","title":"History","text":"The SPECT forward and back-projection method implemented here is based on the 1992 paper by GL Zeng & GT Gullberg \"Frequency domain implementation of the three-dimensional geometric point response correction in SPECT imaging\" (DOI).","category":"page"},{"location":"history/","page":"History","title":"History","text":"Historically there have been relatively few open-source libraries for SPECT image reconstruction, and to the best of our knowledge source code for the Zeng & Gullberg approach has not been available prior to this package.","category":"page"},{"location":"history/","page":"History","title":"History","text":"Starting in about 1995, the ASPIRE library, developed in the early 1990s at the University of Michigan, began providing precompiled binaries (from C99 source code) for 2D SPECT image reconstruction with documentation.","category":"page"},{"location":"history/","page":"History","title":"History","text":"In about 1997, a 3D version of ASPIRE for SPECT reconstruction became available, again as precompiled binaries with documentation. Anastasia Yendiki was a key contributor to the SPECT code. As noted in a 2001 technical report we took pains to ensure that the forward and back-projector were (adjoint) consistent pairs. Around 2001 the work was extended to consider blob basis functions, leading to a 2004 comparison paper.","category":"page"},{"location":"history/","page":"History","title":"History","text":"Somewhere during that period the 3D SPECT projector / backprojector became available as precompiled MEX files for use with the Matlab version of the Michigan Image Reconstruction Toolbox.","category":"page"},{"location":"history/","page":"History","title":"History","text":"The 3D version in ASPIRE precomputes rotated versions of the attenuation map, to save computation at the price of substantially more memory. That trade-off was reasonable in the era before machine learning. Today, with a focus on end-to-end training of image reconstruction methods in all modalities, including SPECT, it is desirable to have methods that use less memory to facilitate GPU implementations. This open-source Julia package is designed for the machine learning era. ","category":"page"},{"location":"history/","page":"History","title":"History","text":"Development work on this package is supported in part by the following projects led by Dr. Yuni Dewaraja:","category":"page"},{"location":"history/","page":"History","title":"History","text":"NIH Grant R01 EB022075\nNIH Grant R01 CA240706","category":"page"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"EditURL = \"../../../lit/examples/4-mlem.jl\"","category":"page"},{"location":"generated/examples/4-mlem/#4-mlem","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"","category":"section"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"This page illustrates ML-EM reconstruction with the Julia package SPECTrecon.","category":"page"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"This page comes from a single Julia file: 4-mlem.jl.","category":"page"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"You can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 4-mlem.ipynb, or open it in binder here: 4-mlem.ipynb.","category":"page"},{"location":"generated/examples/4-mlem/#Setup","page":"SPECTrecon ML-EM","title":"Setup","text":"","category":"section"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"Packages needed here.","category":"page"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"using SPECTrecon: SPECTplan, psf_gauss, project!, backproject!, mlem, mlem!\nusing MIRTjim: jim, prompt\nusing Plots: scatter, plot!, default; default(markerstrokecolor=:auto)","category":"page"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"The following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/4-mlem/#Overview","page":"SPECTrecon ML-EM","title":"Overview","text":"","category":"section"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"Maximum-likelihood expectation-maximization (ML-EM) is a classic algorithm for performing SPECT image reconstruction.","category":"page"},{"location":"generated/examples/4-mlem/#Simulation-data","page":"SPECTrecon ML-EM","title":"Simulation data","text":"","category":"section"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"nx,ny,nz = 64,64,50\nT = Float32\nxtrue = zeros(T, nx,ny,nz)\nxtrue[(1nx÷4):(2nx÷3), 1ny÷5:(3ny÷5), 2nz÷6:(3nz÷6)] .= 1\nxtrue[(2nx÷5):(3nx÷5), 1ny÷5:(2ny÷5), 4nz÷6:(5nz÷6)] .= 2\n\naverage(x) = sum(x) / length(x)\nfunction mid3(x::AbstractArray{T,3}) where {T}\n    (nx,ny,nz) = size(x)\n    xy = x[:,:,ceil(Int, nz÷2)]\n    xz = x[:,ceil(Int,end/2),:]\n    zy = x[ceil(Int, nx÷2),:,:]'\n    return [xy xz; zy fill(average(xy), nz, nz)]\nend\njim(mid3(xtrue), \"Middle slices of xtrue\")","category":"page"},{"location":"generated/examples/4-mlem/#PSF","page":"SPECTrecon ML-EM","title":"PSF","text":"","category":"section"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"Create a synthetic depth-dependent PSF for a single view","category":"page"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"px = 11\npsf1 = psf_gauss( ; ny, px)\njim(psf1, \"PSF for each of $ny planes\")","category":"page"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"In general the PSF can vary from view to view due to non-circular detector orbits. For simplicity, here we illustrate the case where the PSF is the same for every view.","category":"page"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"nview = 60\npsfs = repeat(psf1, 1, 1, 1, nview)\nsize(psfs)","category":"page"},{"location":"generated/examples/4-mlem/#SPECT-system-model-using-LinearMapAA","page":"SPECTrecon ML-EM","title":"SPECT system model using LinearMapAA","text":"","category":"section"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"dy = 8 # transaxial pixel size in mm\nmumap = zeros(T, size(xtrue)) # zero μ-map just for illustration here\nplan = SPECTplan(mumap, psfs, dy; T)\n\nusing LinearMapsAA: LinearMapAA\nusing LinearAlgebra: mul!\nforw! = (y,x) -> project!(y, x, plan)\nback! = (x,y) -> backproject!(x, y, plan)\nidim = (nx,ny,nz)\nodim = (nx,nz,nview)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)","category":"page"},{"location":"generated/examples/4-mlem/#Basic-Expectation-Maximization-(EM)-algorithm","page":"SPECTrecon ML-EM","title":"Basic Expectation-Maximization (EM) algorithm","text":"","category":"section"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"Noisy data","category":"page"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"using Distributions: Poisson\n\nif !@isdefined(ynoisy) # generate (scaled) Poisson data\n    ytrue = A * xtrue\n    target_mean = 20 # aim for mean of 20 counts per ray\n    scale = target_mean / average(ytrue)\n    scatter_fraction = 0.1 # 10% uniform scatter for illustration\n    scatter_mean = scatter_fraction * average(ytrue) # uniform for simplicity\n    background = scatter_mean * ones(T,nx,nz,nview)\n    ynoisy = rand.(Poisson.(scale * (ytrue + background))) / scale\nend\njim(ynoisy, \"$nview noisy projection views\")","category":"page"},{"location":"generated/examples/4-mlem/#ML-EM-algorithm-basic-version","page":"SPECTrecon ML-EM","title":"ML-EM algorithm - basic version","text":"","category":"section"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"x0 = ones(T, nx, ny, nz) # initial uniform image\n\nniter = 30\nif !@isdefined(xhat1)\n    xhat1 = mlem(x0, ynoisy, background, A; niter)\nend\nsize(xhat1)","category":"page"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"This preferable ML-EM version preallocates the output xhat2:","category":"page"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"if !@isdefined(xhat2)\n    xhat2 = copy(x0)\n    mlem!(xhat2, x0, ynoisy, background, A; niter)\nend\n@assert xhat1 ≈ xhat2\n\njim(mid3(xhat2), \"ML-EM at $niter iterations\")","category":"page"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"","category":"page"},{"location":"generated/examples/4-mlem/","page":"SPECTrecon ML-EM","title":"SPECTrecon ML-EM","text":"This page was generated using Literate.jl.","category":"page"},{"location":"methods/#Methods-list","page":"Methods","title":"Methods list","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"","category":"page"},{"location":"methods/#Methods-usage","page":"Methods","title":"Methods usage","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Modules = [SPECTrecon]","category":"page"},{"location":"methods/#SPECTrecon.SPECTrecon","page":"Methods","title":"SPECTrecon.SPECTrecon","text":"SPECTrecon\n\nSystem matrix (forward and back-projector) for SPECT image reconstruction.\n\n\n\n\n\n","category":"module"},{"location":"methods/#SPECTrecon.Rotate1D","page":"Methods","title":"SPECTrecon.Rotate1D","text":"Rotate1D = RotateMode{:one}()\n\nRotate using 3-pass 1D interpolation\n\n\n\n\n\n","category":"constant"},{"location":"methods/#SPECTrecon.Rotate2D","page":"Methods","title":"SPECTrecon.Rotate2D","text":"Rotate2D = RotateMode{:two}()\n\nRotate using 1-pass 2D bilinear interpolation\n\n\n\n\n\n","category":"constant"},{"location":"methods/#SPECTrecon.PlanPSF","page":"Methods","title":"SPECTrecon.PlanPSF","text":"PlanPSF{T,Tf,Ti}( ; nx::Int, nz::Int, px::Int, pz::Int, T::Type)\n\nStruct for storing work arrays and factors for 2D convolution for one thread. Each PSF is px × pz\n\nT datatype of work arrays (subtype of AbstractFloat)\nnx::Int = 128 (ny implicitly the same)\nnz::Int = nx image size is [nx,nx,nz]\npx::Int = 1\npz::Int = px (PSF size)\npadsize::Tuple : (padup, paddown, padleft, padright)\nworkmat [nx+padup+paddown, nz+padleft+padright] 2D padded image for FFT convolution\nworkvecx [nx+padup+paddown,]: 1D work vector\nworkvecz [nz+padleft+padright,]: 1D work vector\nimg_compl [nx+padup+paddown, nz+padleft+padright]: 2D [complex] padded image for FFT\nker_compl [nx+padup+paddown, nz+padleft+padright]: 2D [complex] padded image for FFT\nfft_plan::Tf plan for doing FFT; see plan_fft!\nifft_plan::Ti plan for doing IFFT; see plan_ifft!\n\n\n\n\n\n","category":"type"},{"location":"methods/#SPECTrecon.PlanRotate","page":"Methods","title":"SPECTrecon.PlanRotate","text":"PlanRotate{T, R}\n\nStruct for storing work arrays and factors for 2D square image rotation for one thread\n\nT datatype of work arrays (default Float32)\nR::RotateMode\nnx::Int image size\npadsize::Int : pad each side of image by this much\nworkmat1 [nx + 2 * padsize, nx + 2 * padsize] padded work matrix\nworkmat2 [nx + 2 * padsize, nx + 2 * padsize] padded work matrix\ninterp::SparseInterpolator{T, 2, 1}\n\n\n\n\n\n","category":"type"},{"location":"methods/#SPECTrecon.RotateMode","page":"Methods","title":"SPECTrecon.RotateMode","text":"RotateMode\n\nType to control image rotation method.\n\nRotate1D : 3-pass 1D interpolation\nRotate2D : 1-pass 2D bilinear interpolation\n\n\n\n\n\n","category":"type"},{"location":"methods/#SPECTrecon.SPECTplan","page":"Methods","title":"SPECTrecon.SPECTplan","text":"SPECTplan\n\nStruct for storing key factors for a SPECT system model\n\nT datatype of work arrays\nimgsize size of image\npx,pz psf dimension\nimgr [nx, ny, nz] 3D rotated version of image\nadd_img [nx, ny, nz] 3D image for adding views and backprojection\nmumap [nx,ny,nz] attenuation map, must be 3D, possibly zeros()\nmumapr [nx, ny, nz] 3D rotated mumap\nexp_mumapr [nx, nz] 2D exponential rotated mumap\npsfs [px,pz,ny,nview] point spread function, must be 4D, with px andpz` odd, and symmetric for each slice\nnview number of views, must be integer\nviewangle set of view angles, must be from 0 to 2π\ninterpmeth interpolation method: :one means 1d; :two means 2d\nmode pre-allocation method: :fast means faster; :mem means use less memory\ndy voxel size in y direction (dx is the same value)\nnthread number of CPU threads used to process data; must be integer\nplanrot Vector of struct PlanRotate\nplanpsf Vector of struct PlanPSF\n\nCurrently code assumes the following:\n\neach of the nview projection views is [nx,nz]\nnx = ny\nuniform angular sampling\npsf is symmetric\nmultiprocessing using # of threads specified by Threads.nthreads()\n\nConstructor is not type stable due to the Union, but this is OK because construction is done just once before iterating.\n\n\n\n\n\n","category":"type"},{"location":"methods/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Vector{<:PlanPSF}}","page":"Methods","title":"Base.show","text":"show(io::IO, mime::MIME\"text/plain\", vp::Vector{<:PlanPSF})\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Union{Tuple{R}, Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, Array{PlanRotate{T, R}, 1}}} where {T, R}","page":"Methods","title":"Base.show","text":"show(io::IO, mime::MIME\"text/plain\", vp::Vector{<:PlanRotate})\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Union{Tuple{R}, Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, PlanRotate{T, R}}} where {T, R}","page":"Methods","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", plan::PlanRotate)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Union{Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, PlanPSF{T}}} where T","page":"Methods","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", plan::PlanPSF)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Union{Tuple{T}, Tuple{IO, MIME{Symbol(\"text/plain\")}, SPECTplan{T}}} where T","page":"Methods","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", plan::SPECTplan)\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.sizeof-Tuple{T} where T<:PlanPSF","page":"Methods","title":"Base.sizeof","text":"sizeof(::PlanPSF)\n\nShow size in bytes of PlanPSF object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.sizeof-Tuple{T} where T<:SPECTplan","page":"Methods","title":"Base.sizeof","text":"sizeof(::SPECTplan)\n\nShow size in bytes of SPECTplan object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.sizeof-Tuple{T} where T<:Union{PlanRotate, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"Base.sizeof","text":"sizeof(::PlanRotate)\n\nShow size in bytes of PlanRotate object.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.Ablock-Tuple{SPECTplan, Int64}","page":"Methods","title":"SPECTrecon.Ablock","text":"Ablock(plan, nblocks)\n\nGenerate a vector of linear maps for OSEM. -plan: SPECTrecon plan -nblocks: Number of blocks in OSEM\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject!-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, SPECTplan}","page":"Methods","title":"SPECTrecon.backproject!","text":"backproject!(image, views, plan ; index)\n\nBackproject multiple views into image. Array image is not initialized to zero; caller must do that.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject!-Tuple{AbstractArray{<:Number, 3}, AbstractMatrix{<:Number}, SPECTplan, Int64, Int64}","page":"Methods","title":"SPECTrecon.backproject!","text":"backproject!(image, view, plan, buffer_id, viewidx)\n\nBackproject a single view.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject!-Tuple{AbstractArray{<:Number, 3}, AbstractMatrix{<:Number}, SPECTplan, Int64}","page":"Methods","title":"SPECTrecon.backproject!","text":"backproject!(image, view, plan, viewidx)\n\nBackproject a single view.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, AbstractArray{<:Number, 4}, Number}","page":"Methods","title":"SPECTrecon.backproject","text":"image = backproject(views, mumap, psfs, dy; interpmeth, kwargs...)\n\nSPECT backproject views using attenuation map mumap and PSF array psfs for pixel size dy. This method initializes the plan as a convenience. Most users should use backproject! instead after initializing those, for better efficiency.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.backproject-Tuple{AbstractArray{<:Number, 3}, SPECTplan}","page":"Methods","title":"SPECTrecon.backproject","text":"image = backproject(views, plan ; kwargs...)\n\nSPECT backproject views; this allocates the returned 3D array.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.copy3dj!-Tuple{AbstractMatrix, AbstractArray{<:Any, 3}, Int64}","page":"Methods","title":"SPECTrecon.copy3dj!","text":"copy3dj!(mat2d, mat3d, j)\n\nNon-allocating mat2d .= mat3d[:,j,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv!-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, Vector{<:PlanPSF}}","page":"Methods","title":"SPECTrecon.fft_conv!","text":"fft_conv!(output, image3, ker3, plans)\n\nMutating version of convolving a 3D image3 with a set of 2D symmetric kernels stored in 3D array ker3 using foreach.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, PlanPSF}","page":"Methods","title":"SPECTrecon.fft_conv!","text":"fft_conv!(output, img, ker, plan)\n\nConvolve 2D image img with 2D (symmetric!) kernel ker using FFT, storing the result in output.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv-Union{Tuple{K}, Tuple{I}, Tuple{AbstractMatrix{I}, AbstractMatrix{K}}} where {I<:Number, K<:Number}","page":"Methods","title":"SPECTrecon.fft_conv","text":"fft_conv(img, ker; T)\n\nConvolve 2D image img with 2D (symmetric!) kernel ker using FFT.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv_adj!-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, Vector{<:PlanPSF}}","page":"Methods","title":"SPECTrecon.fft_conv_adj!","text":"fft_conv_adj!(output, image3, ker3, plans)\n\nAdjoint of fft_conv.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv_adj!-Union{Tuple{T}, Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, PlanPSF{T}}} where T","page":"Methods","title":"SPECTrecon.fft_conv_adj!","text":"fft_conv_adj!(output, img, ker, plan)\n\nAdjoint of fft_conv!.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv_adj-Union{Tuple{K}, Tuple{I}, Tuple{AbstractMatrix{I}, AbstractMatrix{K}}} where {I<:Number, K<:Number}","page":"Methods","title":"SPECTrecon.fft_conv_adj","text":"fft_conv_adj(img, ker; T)\n\nAdjoint of fft_conv.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fft_conv_adj2!-Tuple{AbstractArray{<:Number, 3}, AbstractMatrix{<:Number}, AbstractArray{<:Number, 3}, Vector{<:PlanPSF}}","page":"Methods","title":"SPECTrecon.fft_conv_adj2!","text":"fft_conv_adj2!(output, image2, ker3, plans)\n\nMutating version of adjoint of convolving a 2D image2 with each 2D kernel in the 3D array ker3.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.fftshift2!-Tuple{AbstractMatrix, AbstractMatrix}","page":"Methods","title":"SPECTrecon.fftshift2!","text":"fftshift2!(dst, src)\n\nSame as fftshift in 2d, but non-allocating\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imfilterz!-Tuple{PlanPSF}","page":"Methods","title":"SPECTrecon.imfilterz!","text":"imfilterz!(plan)\n\nFFT-based convolution of plan.img_compl and kernel plan.ker_compl (not centered), storing result in plan.workmat. Over-writes plan.ker_compl.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate!","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, image3, θ, plans, ntasks=nthreads)\n\nIn-place version of rotating a 3D image3 by θ in counter-clockwise direction (opposite to imrotate in Julia) using foreach with ntasks.\n\n\n\n\n\n","category":"function"},{"location":"methods/#SPECTrecon.imrotate!-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, Number, Vector{<:PlanRotate}, Symbol}","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, image3, θ, plans, :thread)\n\nMutating version of rotating a 3D image3 by θ in counter-clockwise direction (opposite of imrotate in Julia) writing result into output, using Threads.@threads.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, PlanRotate{<:Number, RotateMode{:one}}}","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, img, θ, plan)\n\nRotate a 2D image img by angle θ ∈ [0,2π] in counter-clockwise direction (opposite to imrotate in Julia) using 3-pass 1d linear interpolations.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate!-Union{Tuple{T}, Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, PlanRotate{T, RotateMode{:two}}}} where T","page":"Methods","title":"SPECTrecon.imrotate!","text":"imrotate!(output, img, θ, plan)\n\nRotate a 2D image img by angle θ ∈ [0,2π] in counter-clockwise direction (opposite to imrotate in Julia) using 2d bilinear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate-Union{Tuple{I}, Tuple{AbstractMatrix{I}, Number}} where I<:Number","page":"Methods","title":"SPECTrecon.imrotate","text":"imrotate(img, θ; method::Symbol=:two)\n\nRotate a 2D image img by angle θ ∈ [0,2π] in counter-clockwise direction (opposite to imrotate in Julia) using either 2d linear interpolation (for :two) or 3-pass 1D interpolation (for :one)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj!","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, image3, θ, plans, ntasks=nthreads)\n\nAdjoint of imrotate! using foreach.\n\n\n\n\n\n","category":"function"},{"location":"methods/#SPECTrecon.imrotate_adj!-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, Number, Vector{<:PlanRotate}, Symbol}","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, image3, θ, plans, :thread)\n\nAdjoint of imrotate! using @threads.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, PlanRotate{<:Number, RotateMode{:one}}}","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, img, θ, plan)\n\nAdjoint of imrotate! for a 2D image using 3-pass 1d linear interpolations.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj!-Union{Tuple{T}, Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, PlanRotate{T, RotateMode{:two}}}} where T","page":"Methods","title":"SPECTrecon.imrotate_adj!","text":"imrotate_adj!(output, img, θ, plan)\n\nAdjoint of imrotate! for a 2D image using 2D bilinear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.imrotate_adj-Union{Tuple{I}, Tuple{AbstractMatrix{I}, Number}} where I<:Number","page":"Methods","title":"SPECTrecon.imrotate_adj","text":"imrotate_adj(img, θ; method::Symbol=:two)\n\nAdjoint of rotating a 2D image img by angle θ ∈ [0,2π] in counter-clockwise direction (opposite to imrotate in Julia) using either 2d linear interpolations or 3-pass 1D interpolation.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.linearinterp!-Tuple{LinearInterpolators.SparseInterpolators.SparseInterpolator, Number, Number, Int64}","page":"Methods","title":"SPECTrecon.linearinterp!","text":"linearinterp!(A, s, e, len)\n\nAssign key values in SparseInterpolator (linear) A that are calculated from s, e and len. s means start (x[1]) e means end (x[end]) len means length (length(x))\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.mlem!-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Union{AbstractArray, LinearMapsAA.LinearMapAO}}","page":"Methods","title":"SPECTrecon.mlem!","text":"mlem!(out, x0, ynoisy, background, A; niter = 20)\n\nInplace version of ML-EM algorithm for emission tomography image reconstruction.\n\nout: Output\nx0: Initial guess\nynoisy: (Noisy) measurements\nbackground: Background effects, e.g., scatters\nA: System matrix\nniter: Number of iterations\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.mlem-Tuple{AbstractArray, Vararg{Any}}","page":"Methods","title":"SPECTrecon.mlem","text":"mlem(x0, ynoisy, background, A; niter = 20)\n\nML-EM algorithm for emission tomography image reconstruction.\n\nx0: Initial guess\nynoisy: (Noisy) measurements\nbackground: Background effects, e.g., scatters\nA: System matrix\nniter: Number of iterations\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.mul3dj!-Tuple{AbstractArray{<:Any, 3}, AbstractMatrix, Int64}","page":"Methods","title":"SPECTrecon.mul3dj!","text":"mul3dj!(mat3d, mat2d, j)\n\nNon-allocating mat3d[:,j,:] *= mat2d\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.osem!-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Union{Vector{AbstractArray}, Vector{LinearMapsAA.LinearMapAO}}}","page":"Methods","title":"SPECTrecon.osem!","text":"osem!(out, x0, ynoisy, background, Ab; niter = 20)\n\nOS-EM algorithm for SPECT reconstruction.\n\nout: Output\nx0: Initial estimate\nynoisy: (Noisy) measurements\nbackground: Background effects, e.g., scatters\nAb: Vector of system matrix\nniter: Number of iterations\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.osem-Tuple{AbstractArray, Vararg{Any}}","page":"Methods","title":"SPECTrecon.osem","text":"osem(x0, ynoisy, background, Ab; niter = 20)\n\nOS-EM algorithm for SPECT reconstruction.\n\nx0: Initial guess\nynoisy: (Noisy) measurements\nbackground: Background effects, e.g., scatters\nAb: Vector of system matrix\nniter: Number of iterations\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.pad2sizezero!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix, Tuple{Int64, Int64}}} where T","page":"Methods","title":"SPECTrecon.pad2sizezero!","text":"pad2sizezero!(output, img, padsize)\n\nNon-allocating version of padding: `output[paddims[1]+1 : paddims[1]+dims[1],         paddims[2]+1 : paddims[2]+dims[2]]) .= img\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.pad_it!-Union{Tuple{T}, Tuple{D}, Tuple{AbstractArray{T, D}, NTuple{D, Int64}}} where {D, T<:Number}","page":"Methods","title":"SPECTrecon.pad_it!","text":"pad_it!(X, padsize)\n\nZero-pad X to padsize\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.padrepl!-Tuple{AbstractMatrix, AbstractMatrix, NTuple{4, Int64}}","page":"Methods","title":"SPECTrecon.padrepl!","text":"padrepl!(output, img, padsize)\n\nPad with replication from img into output\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.padzero!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix, NTuple{4, Int64}}} where T","page":"Methods","title":"SPECTrecon.padzero!","text":"padzero!(output, img, pad_x, pad_y)\n\nMutating version of padding a 2D image by filling zeros. Output has size (size(img, 1) + padsize[1] + padsize[2], size(img, 2) + padsize[3] + padsize[4]).\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plan_psf-Tuple{}","page":"Methods","title":"SPECTrecon.plan_psf","text":"plan_psf( ; nx::Int, nz::Int, px::Int, pz::Int, nthread::Int, T::Type)\n\nMake Vector of structs for storing work arrays and factors for 2D convolution with SPECT depth-dependent PSF model, threaded across planes parallel to detector. Option\n\nnx::Int = 128\nnz::Int = nx\npx::Int = 1\npz::Int = px PSF size is px × pz\nT : datatype of work arrays, defaults to Float32\nnthread::Int # of threads, defaults to Threads.nthreads()\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plan_rotate-Tuple{Int64}","page":"Methods","title":"SPECTrecon.plan_rotate","text":"plan_rotate(nx::Int; T::Type{<:AbstractFloat}, method::Symbol)\n\nMake Vector of PlanRotate structs for storing work arrays and factors for threaded rotation of a stack of 2D square images.\n\nInput\n\nnx::Int must equal to ny (square images only)\n\nOption\n\nT : datatype of work arrays, defaults to Float32\nmethod::Symbol : default is :two for 2D interpolation; use :one for 3-pass rotation with 1D interpolation\nnthread::Int : default to Threads.nthreads() The other useful option is 1 when rotating just one image.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus1di!-Tuple{AbstractMatrix, AbstractVector, Int64}","page":"Methods","title":"SPECTrecon.plus1di!","text":"plus1di!(mat2d, mat1d)\n\nNon-allocating mat2d[i, :] += mat1d\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus1dj!-Tuple{AbstractMatrix, AbstractVector, Int64}","page":"Methods","title":"SPECTrecon.plus1dj!","text":"plus1dj!(mat2d, mat1d)\n\nNon-allocating mat2d[:, j] += mat1d\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus2di!-Tuple{AbstractVector, AbstractMatrix, Int64}","page":"Methods","title":"SPECTrecon.plus2di!","text":"plus2di!(mat1d, mat2d, i)\n\nNon-allocating mat1d += mat2d[i,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus2dj!-Tuple{AbstractVector, AbstractMatrix, Int64}","page":"Methods","title":"SPECTrecon.plus2dj!","text":"plus2dj!(mat1d, mat2d, j)\n\nNon-allocating mat1d += mat2d[:,j]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus3di!-Tuple{AbstractMatrix, AbstractArray{<:Any, 3}, Int64}","page":"Methods","title":"SPECTrecon.plus3di!","text":"plus3di!(mat2d, mat3d, i)\n\nNon-allocating mat2d += mat3d[i,:,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus3dj!-Tuple{AbstractMatrix, AbstractArray{<:Any, 3}, Int64}","page":"Methods","title":"SPECTrecon.plus3dj!","text":"plus3dj!(mat2d, mat3d, j)\n\nNon-allocating mat2d += mat3d[:,j,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.plus3dk!-Tuple{AbstractMatrix, AbstractArray{<:Any, 3}, Int64}","page":"Methods","title":"SPECTrecon.plus3dk!","text":"plus3dk!(mat2d, mat3d, k)\n\nNon-allocating mat2d += mat3d[:,:,k]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project!-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, SPECTplan}","page":"Methods","title":"SPECTrecon.project!","text":"project!(views, image, plan; index)\n\nProject image into multiple views with indexes index (defaults to 1:nview). The 3D views array must be pre-allocated, but need not be initialized.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project!-Tuple{AbstractMatrix{<:Number}, AbstractArray{<:Number, 3}, SPECTplan, Int64, Int64}","page":"Methods","title":"SPECTrecon.project!","text":"project!(view, plan, image, buffer_id, viewidx)\n\nSPECT projection of image into a single view with index viewidx. The view must be pre-allocated but need not be initialized to zero.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project!-Tuple{AbstractMatrix{<:Number}, AbstractArray{<:Number, 3}, SPECTplan, Int64}","page":"Methods","title":"SPECTrecon.project!","text":"project!(view, plan, image, viewidx)\n\nSPECT projection of image into a single view with index viewidx. The view must be pre-allocated but need not be initialized to zero.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project-Tuple{AbstractArray{<:Number, 3}, AbstractArray{<:Number, 3}, AbstractArray{<:Number, 4}, Number}","page":"Methods","title":"SPECTrecon.project","text":"views = project(image, mumap, psfs, dy; interpmeth, kwargs...)\n\nConvenience method for SPECT forward projector that does all allocation including initializing plan.\n\nIn\n\nimage : 3D array (nx,ny,nz)\nmumap : (nx,ny,nz) 3D attenuation map, possibly zeros()\npsfs : 4D PSF array\ndy::RealU : pixel size\n\nOption\n\ninterpmeth : :one or :two\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.project-Tuple{AbstractArray{<:Number, 3}, SPECTplan}","page":"Methods","title":"SPECTrecon.project","text":"views = project(image, plan ; kwargs...)\n\nConvenience method for SPECT forward projector that allocates and returns views.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.psf_gauss-Tuple{}","page":"Methods","title":"SPECTrecon.psf_gauss","text":"psf_gauss( ; ny, px, pz, fwhm_start, fwhm_end, fwhm, fwhm_x, fwhm_z, T)\n\nCreate depth-dependent Gaussian PSFs having specified full-width half-maximum (FHWM) values.\n\nOptions\n\n'ny::Int = 128'\n'px::Int = 11' (should be odd)\n'pz::Int = px' (should be odd)\n'fwhm_start::Real = 1'\n'fwhm_end::Real = 4'\n'fwhm::AbstractVector{<:Real} = range(fwhmstart, fwhmend, ny)'\n'fwhm_x::AbstractVector{<:Real} = fwhm,\n'fwhmz::AbstractVector{<:Real} = fwhmx'\n'T::Type == Float32'\n\nReturned psf is [px, pz, ny] where each PSF sums to 1.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rot180!-Tuple{AbstractMatrix, AbstractMatrix}","page":"Methods","title":"SPECTrecon.rot180!","text":"rot180!(B::AbstractMatrix, A::AbstractMatrix)\n\nIn place version of rot180, returning rotation of A in B.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rot_f90!-Tuple{AbstractMatrix, AbstractMatrix, Int64}","page":"Methods","title":"SPECTrecon.rot_f90!","text":"rot_f90!(output, img, m)\n\nIn-place version of rotating an image by 90/180/270 degrees\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rot_f90_adj!-Tuple{AbstractMatrix, AbstractMatrix, Int64}","page":"Methods","title":"SPECTrecon.rot_f90_adj!","text":"rot_f90_adj!(output, img, m)\nThe adjoint of rotating an image by 90/180/270 degrees\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_x!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_x!","text":"rotate_x!(output, img, tan_θ, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_x_adj!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_x_adj!","text":"rotate_x_adj!(output, img, tan_θ, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_y!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_y!","text":"rotate_y!(output, img, sin_θ, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotate_y_adj!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}, Number, LinearInterpolators.SparseInterpolators.SparseInterpolator}","page":"Methods","title":"SPECTrecon.rotate_y_adj!","text":"rotate_y_adj!(output, img, sin_θ, interp)\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotl90!-Tuple{AbstractMatrix, AbstractMatrix}","page":"Methods","title":"SPECTrecon.rotl90!","text":"rotl90!(B::AbstractMatrix, A::AbstractMatrix)\n\nIn place version of rotl90, returning rotation of A in B.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.rotr90!-Tuple{AbstractMatrix, AbstractMatrix}","page":"Methods","title":"SPECTrecon.rotr90!","text":"rotr90!(B::AbstractMatrix, A::AbstractMatrix)\n\nIn place version of rotr90, returning rotation of A in B.\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.scale3dj!-Tuple{AbstractMatrix, AbstractArray{<:Any, 3}, Int64, Number}","page":"Methods","title":"SPECTrecon.scale3dj!","text":"scale3dj!(mat2d, mat3d, j, s)\n\nNon-allocating mat2d = s * mat3d[:,j,:]\n\n\n\n\n\n","category":"method"},{"location":"methods/#SPECTrecon.spawner-Tuple{Any, Int64, Int64}","page":"Methods","title":"SPECTrecon.spawner","text":"spawner(fun!, nthread::Int, ntask::Int)\n\nApply fun!(buffer_id, task) for task in 1:ntask where buffer_id is in {1, …, nthread}\n\nA single-thread version of this would simply be fun!.(1, 1:ntask)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SPECTrecon","category":"page"},{"location":"#Documentation-for-[SPECTrecon](https://github.com/JuliaImageRecon/SPECTrecon.jl)","page":"Home","title":"Documentation for SPECTrecon","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia module provides SPECT forward and back projectors for parallel-beam collimators, accounting for attenuation and depth-dependent collimator response. (Compton scatter within the object is not modeled.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Designed for use with the Michigan Image Reconstruction Toolbox (MIRT) and similar frameworks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The method implemented here is based on the 1992 paper by GL Zeng & GT Gullberg \"Frequency domain implementation of the three-dimensional geometric point response correction in SPECT imaging\" (IEEE Tr. on Nuclear Science, 39(5-1):1444-53, Oct 1992) (DOI).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The forward projection method works as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The emission image and the attenuation map are rotated (slice by slice) to the desired view angle using either 2D bilinear interpolation or a 3-pass rotation method based on linear interpolation.\nEach (rotated) plane is convolved with the given point spread function (PSF) of the collimator and summed, accounting for attenuation using the \"central ray\" approximation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The back-projection method is the exact adjoint of the forward projector.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the \"Examples\" for details.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"EditURL = \"../../../lit/examples/1-overview.jl\"","category":"page"},{"location":"generated/examples/1-overview/#1-overview","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"","category":"section"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"This page gives an overview of the Julia package SPECTrecon.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"This page comes from a single Julia file: 1-overview.jl.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"You can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 1-overview.ipynb, or open it in binder here: 1-overview.ipynb.","category":"page"},{"location":"generated/examples/1-overview/#Setup","page":"SPECTrecon overview","title":"Setup","text":"","category":"section"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Packages needed here.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"using SPECTrecon: plan_psf, psf_gauss, SPECTplan\nusing SPECTrecon: project, project!, backproject, backproject!\nusing MIRTjim: jim, prompt\nusing LinearAlgebra: mul!\nusing LinearMapsAA: LinearMapAA\nusing Plots: scatter, plot!, default; default(markerstrokecolor=:auto)\nusing Plots # @animate, gif\nusing InteractiveUtils: versioninfo","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"The following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/1-overview/#Overview","page":"SPECTrecon overview","title":"Overview","text":"","category":"section"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"To perform SPECT image reconstruction, one must have a model for the imaging system encapsulated in a forward projector and back projector.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Mathematically, we write the forward projection process in SPECT as \"y = A * x\" where A is a \"system matrix\" that models the physics of the imaging system (including depth-dependent collimator/detector response and attenuation) and \"x\" is the current guess of the emission image.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"However, in code we usually cannot literally store \"A\" as dense matrix because it is too large. A typical size in SPECT is that the image x is nx × ny × nz = 128 × 128 × 100 and the array of projection views y is nx × nz × nview = 128 × 100 × 120. So the system matrix A has 1536000 × 1638400 elements which is far to many to store, even accounting for some sparsity.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Instead, we write functions called forward projectors that calculate A * x \"on the fly\".","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Similarly, the operation A' * y is called \"back projection\", where A' denotes the transpose or \"adjoint\" of A.","category":"page"},{"location":"generated/examples/1-overview/#Example","page":"SPECTrecon overview","title":"Example","text":"","category":"section"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"To illustrate forward and back projection, it is easiest to start with a simulation example using a digital phantom. The fancy way would be to use a 3D phantom from ImagePhantoms, but instead we just use two simple cubes.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"nx,ny,nz = 128,128,80\nT = Float32\nxtrue = zeros(T, nx,ny,nz)\nxtrue[(1nx÷4):(2nx÷3), 1ny÷5:(3ny÷5), 2nz÷6:(3nz÷6)] .= 1\nxtrue[(2nx÷5):(3nx÷5), 1ny÷5:(2ny÷5), 4nz÷6:(5nz÷6)] .= 2\n\naverage(x) = sum(x) / length(x)\nfunction mid3(x::AbstractArray{T,3}) where {T}\n    (nx,ny,nz) = size(x)\n    xy = x[:,:,ceil(Int, nz÷2)]\n    xz = x[:,ceil(Int,end/2),:]\n    zy = x[ceil(Int, nx÷2),:,:]'\n    return [xy xz; zy fill(average(x), nz, nz)]\nend\njim(mid3(xtrue), \"Middle slices of x\")","category":"page"},{"location":"generated/examples/1-overview/#PSF","page":"SPECTrecon overview","title":"PSF","text":"","category":"section"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Create a synthetic depth-dependent PSF for a single view","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"px = 11\npsf1 = psf_gauss( ; ny, px, fwhm_end = 6)\njim(psf1, \"PSF for each of $ny planes\")","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"In general the PSF can vary from view to view due to non-circular detector orbits. For simplicity, here we illustrate the case where the PSF is the same for every view.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"nview = 60\npsfs = repeat(psf1, 1, 1, 1, nview)\nsize(psfs)","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Plan the PSF modeling (see 3-psf.jl)","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"plan = plan_psf( ; nx, nz, px)","category":"page"},{"location":"generated/examples/1-overview/#Basic-SPECT-forward-projection","page":"SPECTrecon overview","title":"Basic SPECT forward projection","text":"","category":"section"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Here is a simple illustration of a SPECT forward projection operation. (This is a memory inefficient way to do it!)","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"dy = 4 # transaxial pixel size in mm\nmumap = zeros(T, size(xtrue)) # μ-map just zero for illustration here\nviews = project(xtrue, mumap, psfs, dy)\nsize(views)","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Display the calculated (i.e., simulated) projection views","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"jim(views[:,:,1:4:end], \"Every 4th of $nview projection views\")","category":"page"},{"location":"generated/examples/1-overview/#Basic-SPECT-back-projection","page":"SPECTrecon overview","title":"Basic SPECT back projection","text":"","category":"section"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"This illustrates an \"unfiltered backprojection\" that leads to a very blurry image (again, with a simple memory inefficient usage).","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"First, back-project two \"rays\" to illustrate the depth-dependent PSF.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"tmp = zeros(T, size(views))\ntmp[nx÷2, nz÷2, nview÷5] = 1\ntmp[nx÷2, nz÷2, 1] = 1\ntmp = backproject(tmp, mumap, psfs, dy)\njim(mid3(tmp), \"Back-projection of two rays\")","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Now back-project all the views of the phantom.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"back = backproject(views, mumap, psfs, dy)\njim(mid3(back), \"Back-projection of ytrue\")","category":"page"},{"location":"generated/examples/1-overview/#Memory-efficiency","page":"SPECTrecon overview","title":"Memory efficiency","text":"","category":"section"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"For iterative reconstruction, one must do forward and back-projection repeatedly. It is more efficient to pre-allocate work arrays for those operations, instead of repeatedly making system calls.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Here we illustrate the memory efficient versions that are recommended for iterative SPECT reconstruction.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"First construction the SPECT plan.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"#viewangle = (0:(nview-1)) * 2π # default\nplan = SPECTplan(mumap, psfs, dy; T)","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Mutating version of forward projection:","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"tmp = Array{T}(undef, nx, nz, nview)\nproject!(tmp, xtrue, plan)\n@assert tmp == views","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Mutating version of back-projection:","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"tmp = Array{T}(undef, nx, ny, nz)\nbackproject!(tmp, views, plan)\n@assert tmp ≈ back","category":"page"},{"location":"generated/examples/1-overview/#Using-LinearMapAA","page":"SPECTrecon overview","title":"Using LinearMapAA","text":"","category":"section"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Calling project! and backproject! repeatedly leads to application-specific code. More general code uses the fact that SPECT projection and back-projection are linear operations, so we use LinearMapAA to define a \"system matrix\" for these operations.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"forw! = (y,x) -> project!(y, x, plan)\nback! = (x,y) -> backproject!(x, y, plan)\nidim = (nx,ny,nz)\nodim = (nx,nz,nview)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Simple forward and back-projection:","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"@assert A * xtrue == views\n@assert A' * views ≈ back","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Mutating version:","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"tmp = Array{T}(undef, nx, nz, nview)\nmul!(tmp, A, xtrue)\n@assert tmp == views\ntmp = Array{T}(undef, nx, ny, nz)\nmul!(tmp, A', views)\n@assert tmp ≈ back","category":"page"},{"location":"generated/examples/1-overview/#Units","page":"SPECTrecon overview","title":"Units","text":"","category":"section"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"The pixel dimensions deltas can (and should!) be values with units.","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"Here is an example with units ... (todo)","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"using UnitfulRecipes using Unitful: mm","category":"page"},{"location":"generated/examples/1-overview/#Projection-view-animation","page":"SPECTrecon overview","title":"Projection view animation","text":"","category":"section"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"anim = @animate for i in 1:nview\n    ymax = maximum(views)\n    jim(views[:,:,i],\n        \"SPECT projection view $i of $nview\",\n        clim = (0, ymax),\n    )\nend\ngif(anim, \"views.gif\", fps = 8)","category":"page"},{"location":"generated/examples/1-overview/#Reproducibility","page":"SPECTrecon overview","title":"Reproducibility","text":"","category":"section"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"This page was generated with the following version of Julia:","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"using InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"And with the following package versions","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"import Pkg; Pkg.status()","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"","category":"page"},{"location":"generated/examples/1-overview/","page":"SPECTrecon overview","title":"SPECTrecon overview","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"EditURL = \"../../../lit/examples/3-psf.jl\"","category":"page"},{"location":"generated/examples/3-psf/#3-psf","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"","category":"section"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"This page explains the PSF portion of the Julia package SPECTrecon.jl.","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"This page comes from a single Julia file: 3-psf.jl.","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"You can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 3-psf.ipynb, or open it in binder here: 3-psf.ipynb.","category":"page"},{"location":"generated/examples/3-psf/#Setup","page":"SPECTrecon PSF","title":"Setup","text":"","category":"section"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"Packages needed here.","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"using SPECTrecon: psf_gauss, plan_psf, fft_conv!, fft_conv_adj!\nusing MIRTjim: jim, prompt\nusing Plots: scatter, scatter!, plot!, default\ndefault(markerstrokecolor=:auto, markersize=3)","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"The following line is helpful when running this example.jl file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/3-psf/#Overview","page":"SPECTrecon PSF","title":"Overview","text":"","category":"section"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"After rotating the image and the attenuation map, second step in SPECT image forward projection is to apply depth-dependent point spread function (PSF). Each (rotated) image plane is a certain distance from the SPECT detector and must be convolved with the 2D PSF appropriate for that plane.","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"Because SPECT has relatively poor spatial resolution, the PSF is usually fairly wide, so convolution using FFT operations is typically more efficient than direct spatial convolution.","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"Following other libraries like FFTW.jl, the PSF operations herein start with a plan where work arrays are preallocated for subsequent use. The plan is a Vector of PlanPSF objects: one for each thread. (Parallelism is across planes for a 3D image volume.) The number of threads defaults to Threads.nthreads().","category":"page"},{"location":"generated/examples/3-psf/#Example","page":"SPECTrecon PSF","title":"Example","text":"","category":"section"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"Start with a 3D image volume.","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"T = Float32 # work with single precision to save memory\nnx = 32\nnz = 30\nimage = zeros(T, nx, nx, nz) # ny = nx required\nimage[1nx÷4, 1nx÷4, 3nz÷4] = 1\nimage[2nx÷4, 2nx÷4, 2nz÷4] = 1\nimage[3nx÷4, 3nx÷4, 1nz÷4] = 1\njim(image, \"Original image\")","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"Create a synthetic gaussian depth-dependent PSF for a single view","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"px = 11\nnview = 1 # for simplicity in this illustration\npsf = repeat(psf_gauss( ; ny=nx, px), 1, 1, 1, nview)\njim(psf, \"PSF for each of $nx planes\")","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"Now plan the PSF modeling by specifying","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"the image size (must be square)\nthe PSF size: must be px × pz × ny × nview\nthe Type used for the work arrays.","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"plan = plan_psf( ; nx, nz, px, T)","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"Here are the internals for the plan for the first thread:","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"plan[1]","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"With this plan pre-allocated, now we can apply the depth-dependent PSF to the image volume (assumed already rotated here).","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"result = similar(image) # allocate memory for the result\nfft_conv!(result, image, psf[:,:,:,1], plan) # mutates the first argument\njim(result, \"After applying PSF\")","category":"page"},{"location":"generated/examples/3-psf/#Adjoint","page":"SPECTrecon PSF","title":"Adjoint","text":"","category":"section"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"To ensure adjoint consistency between SPECT forward- and back-projection, there is also an adjoint routine:","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"adj = similar(result)\nfft_conv_adj!(adj, result, psf[:,:,:,1], plan)\njim(adj, \"Adjoint of PSF modeling\")","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"The adjoint is not the same as the inverse so one does not expect the output here to match the original image!","category":"page"},{"location":"generated/examples/3-psf/#LinearMap","page":"SPECTrecon PSF","title":"LinearMap","text":"","category":"section"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"One can form a linear map corresponding to PSF modeling using LinearMapAA. Perhaps the main purpose is simply for verifying adjoint correctness.","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"using LinearMapsAA: LinearMapAA\n\nnx, nz, px = 10, 7, 5 # small size for illustration\npsf3 = psf_gauss( ; ny=nx, px)\nplan = plan_psf( ; nx, nz, px, T)\nidim = (nx,nx,nz)\nodim = (nx,nx,nz)\nforw! = (y,x) -> fft_conv!(y, x, psf3, plan)\nback! = (x,y) -> fft_conv_adj!(x, y, psf3, plan)\nA = LinearMapAA(forw!, back!, (prod(odim),prod(idim)); T, odim, idim)\n\nAfull = Matrix(A)\nAadj = Matrix(A')\njim(cat(dims=3, Afull, Aadj'), \"Linear map for PSF modeling and its adjoint\")","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"The following check verifies adjoint consistency:","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"@assert Afull ≈ Aadj'","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"","category":"page"},{"location":"generated/examples/3-psf/","page":"SPECTrecon PSF","title":"SPECTrecon PSF","text":"This page was generated using Literate.jl.","category":"page"}]
}
